<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>Echo of the Ember – Extended</title>
<style>
  :root{
    --fg:#e8f0ff;--bg:#0b0e14;--muted:#93a1b2;--accent:#00f6c7;--warn:#ff4d4d;--ok:#50c878;--panel:#0f1320;--edge:#1c2236;
  }
  html,body{height:100%;margin:0;background:radial-gradient(1200px 600px at 50% 0%, #121725 0%, #0b0e14 60%);color:var(--fg);font-family:Inter, ui-sans-serif, system-ui, Segoe UI, Roboto, Helvetica, Arial}
  *{box-sizing:border-box}
  .flex{display:flex}.col{flex-direction:column}.center{align-items:center;justify-content:center}
  .btn{background:linear-gradient(#151b2b,#0f1424);border:2px solid var(--edge);color:var(--fg);padding:.6rem 1rem;margin:.3rem 0;font-size:18px;cursor:pointer;border-radius:12px;transition:transform .06s ease, box-shadow .2s, border-color .2s}
  .btn:hover{transform:translateY(-1px);box-shadow:0 10px 24px rgba(0,0,0,.35);border-color:#2b3554}
  .btn:active{transform:translateY(1px)}
  .btn.primary{border-color:var(--accent)}
  .btn.danger{border-color:var(--warn)}
  .btn.ok{border-color:var(--ok)}
  .btn:disabled{opacity:.55;cursor:not-allowed}

  .menu{position:absolute;inset:0;display:none}
  .menu.active{display:flex}
  .panel{background:linear-gradient(180deg,var(--panel),#0c1020 40%, #0b0e14);border:2px solid var(--edge);border-radius:18px;box-shadow:0 40px 100px rgba(0,0,0,.55), inset 0 0 0 1px rgba(255,255,255,.03);padding:20px;min-width:520px;max-width:860px}
  h1,h2,h3{margin:.2rem 0}
  h1.title{font-size:48px;letter-spacing:.5px;line-height:1.1;text-shadow:0 2px 0 #000, 0 0 28px rgba(0,246,199,.35)}
  p.mono{font-family: ui-monospace, SFMono-Regular, Menlo, Consolas, monospace; color: var(--muted)}
  .row{display:flex;gap:12px;flex-wrap:wrap}
  .note{color:#aab1c4;font-size:12px;margin-top:6px}
  .grid{display:grid;grid-template-columns:repeat(2,minmax(200px,1fr));gap:12px}
  .slot{border:2px dashed var(--edge);border-radius:14px;padding:12px;background:rgba(255,255,255,.02)}
  .slot h3{margin:0 0 6px 0}
  input[type="text"], select{width:100%;background:#0b1022;border:2px solid var(--edge);color:var(--fg);padding:.55rem;border-radius:10px;font-size:16px}
  label{font-size:14px;color:#b9c1d8}

  .toast{position:fixed;left:50%;top:8%;transform:translateX(-50%);background:#0b1124;border:2px solid var(--edge);padding:.65rem 1rem;border-radius:12px;display:none;box-shadow:0 10px 24px rgba(0,0,0,.35);z-index:50}
  .toast.show{display:block}

  .hud{position:absolute;left:0;right:0;top:0;display:flex;justify-content:center;gap:8px;padding:8px 8px;font-family: ui-monospace, monospace;pointer-events:none;z-index:10;flex-wrap:wrap}
  .hud .pill{background:rgba(10,14,28,.9);border:2px solid var(--edge);padding:6px 10px;border-radius:12px}

  .pauseOverlay{position:absolute;inset:0;background:rgba(5,8,16,.78);backdrop-filter:blur(2px);display:none;z-index:40}
  .pauseOverlay.active{display:flex}

  .cutscene{position:absolute;inset:auto 0 0 0;background:rgba(5,8,16,.92);padding:14px 16px;border-top:2px solid var(--edge);font-family: ui-monospace, monospace;z-index:30}
  .cutscene .name{color:var(--accent)}
  .egg{position:fixed;inset:auto 0 12% 0;display:none;justify-content:center;z-index:60}
  .egg .bubble{background:#0b1124;border:2px solid var(--accent);padding:10px 14px;border-radius:12px;box-shadow:0 10px 24px rgba(0,0,0,.35)}

  /* Chat overlay */
  .chatOverlay{position:absolute;inset:0;display:none;align-items:center;justify-content:center;z-index:70;background:rgba(5,8,16,.72);backdrop-filter:blur(2px)}
  .chatOverlay.active{display:flex}
  .chatBox{width:min(720px,92vw);background:#0b1124;border:2px solid var(--edge);border-radius:16px;box-shadow:0 30px 80px rgba(0,0,0,.65);padding:14px}
  .chatBox .head{display:flex;justify-content:space-between;align-items:center;margin-bottom:10px}
  .chatBox .head .title{font-family: ui-monospace, monospace;color:var(--muted)}
  .chatBox input{width:100%;padding:.7rem;border-radius:12px;border:2px solid var(--edge);background:#0b1022;color:var(--fg);font-size:16px}
  .chatHint{margin-top:8px;color:#9fb0c6;font-size:12px;font-family: ui-monospace, monospace}

  canvas{image-rendering: pixelated; image-rendering: crisp-edges; width: 960px; height: 540px; border:2px solid var(--edge); border-radius:14px; background:#000; box-shadow:0 30px 80px rgba(0,0,0,.6)}
  .viewport{position:relative;display:flex;gap:16px;align-items:flex-start;justify-content:center;margin:18px}
  @media (max-width: 1020px){ canvas{ width: 92vw; height: calc(92vw * 9 / 16);} }

  /* subtle CRT scanlines */
  .crt:before{content:"";position:absolute;inset:0;pointer-events:none;background:repeating-linear-gradient(to bottom, rgba(255,255,255,.03), rgba(255,255,255,.03) 1px, transparent 2px, transparent 4px);border-radius:14px}

  /* small helper */
  .small{font-size:12px;color:#aab1c4;font-family: ui-monospace, monospace}
</style>
</head>
<body>
<div class="viewport flex col center crt">
  <canvas id="game" width="320" height="180" aria-label="Retro canvas"></canvas>

  <div class="hud" id="hud" style="display:none">
    <div class="pill" id="hp">HP: --</div>
    <div class="pill" id="inv">Items: —</div>
    <div class="pill" id="where">Area: —</div>
    <div class="pill" id="diff">Diff: —</div>
    <div class="pill" id="slotsHud">Slots: —</div>
    <div class="pill" id="mpHud" style="display:none">MP: —</div>
  </div>

  <!-- MAIN MENU -->
  <section id="menu" class="menu active flex center">
    <div class="panel">
      <h1 class="title" id="tTitle">Echo of the Ember</h1>
      <div class="row">
        <a class="btn" id="btnControlsLink" href="https://Website.com" target="_blank" rel="noopener">Controls (Website)</a>
        <button class="btn" id="btnMultiplayer">Multiplayer</button>
      </div>

      <div class="row">
        <button class="btn primary" id="btnNew">New Game</button>
        <button class="btn" id="btnLoad">Load Game</button>
        <button class="btn" id="btnSettings">Settings</button>
        <button class="btn danger" id="btnExit">Exit</button>
      </div>
      <p class="note" id="tNote">3 save slots. Hard = no saves + permadeath.</p>
    </div>
  </section>

  <!-- MULTIPLAYER -->
  <section id="multiplayer" class="menu flex center">
    <div class="panel">
      <h2>Multiplayer (Prototype)</h2>
      <p class="small">
        Host erzeugt Code (6 Zeichen). Join = Code eingeben.<br/>
        Hinweis: “Echtes Online” braucht Server/Signaling. Hier ist ein Lobby-Prototyp + optional Local-Coop.
      </p>
      <div class="row" style="margin-top:10px">
        <button class="btn ok" id="btnHost">Host</button>
        <div style="flex:1;min-width:260px">
          <label>Join Code</label>
          <input id="joinCode" type="text" maxlength="6" placeholder="ABC123" />
        </div>
        <button class="btn primary" id="btnJoin">Join</button>
      </div>
      <div class="row" style="margin-top:8px">
        <div class="pill" id="mpStatus">MP: not active</div>
        <div class="pill" id="mpCode">Code: —</div>
      </div>
      <div class="row" style="margin-top:8px">
        <button class="btn" id="backFromMp">Back</button>
      </div>
    </div>
  </section>

  <!-- LOAD MENU -->
  <section id="load" class="menu flex center">
    <div class="panel">
      <h2 id="tLoadTitle">Load / Create Game</h2>
      <div id="slots" class="grid"></div>
      <div class="row" style="margin-top:8px">
        <button class="btn" id="backFromLoad">Back</button>
      </div>
    </div>
  </section>

  <!-- SETTINGS -->
  <section id="settings" class="menu flex center">
    <div class="panel">
      <h2 id="tSettings">Settings</h2>

      <div class="row">
        <div style="flex:1">
          <label id="tLang">Language</label>
          <select id="lang">
            <option value="de">Deutsch</option>
            <option value="en">English</option>
            <option value="fr">Français</option>
          </select>
          <p class="note" id="tLangNote">UI + messages.</p>
        </div>

        <div style="flex:1">
          <label id="tDiff">Difficulty</label>
          <select id="difficulty">
            <option value="easy">Easy</option>
            <option value="ok" selected>Ok</option>
            <option value="hard">Hard (no saves, permadeath)</option>
          </select>
        </div>

        <div style="flex:1">
          <label id="tNick">Nickname (local)</label>
          <div class="row">
            <input id="username" type="text" placeholder="Nickname" />
            <button id="btnLogin" class="btn ok" title="Save locally">Save</button>
          </div>
          <p class="note" id="tNickNote">Nickname is stored only in your browser.</p>
        </div>
      </div>

      <div class="row" style="margin-top:8px">
        <button class="btn" id="backFromSettings">Back</button>
      </div>
    </div>
  </section>

  <!-- PAUSE -->
  <section id="pause" class="pauseOverlay flex center col">
    <div class="panel" style="min-width:360px">
      <h2 id="tPaused">Paused</h2>
      <div class="row">
        <button id="btnResume" class="btn primary">Resume (T)</button>
        <button id="btnSave" class="btn ok">Save</button>
        <button id="btnMainMenu" class="btn">Main Menu</button>
      </div>
      <p class="note" id="tPauseNote">Hard mode disables saving.</p>
    </div>
  </section>

  <!-- CHAT -->
  <section id="chat" class="chatOverlay">
    <div class="chatBox">
      <div class="head">
        <div class="title" id="tChatTitle">Mini Chat (R)</div>
        <div class="title" id="tChatClose">Esc to close</div>
      </div>
      <input id="chatInput" type="text" placeholder="Type something and press Enter…" maxlength="40" />
      <div class="chatHint" id="tChatHint">Tip: There are secret codes…</div>
    </div>
  </section>

  <div id="cutscene" class="cutscene" style="display:none"></div>
  <div id="toast" class="toast"></div>
  <div id="egg" class="egg"><div class="bubble">Hi Pia, this game was designed for you</div></div>
</div>

<script>
(function(){
  // FAILSAFE
  window.addEventListener('error', (e)=>{
    const t = document.getElementById('toast');
    if(t){
      t.textContent = "JS Error: " + (e?.message || "unknown");
      t.classList.add('show');
    }
    console.error(e);
  });

  const canvas = document.getElementById('game');
  const ctx = canvas.getContext('2d');

  const HUD = {
    root: document.getElementById('hud'),
    hp: document.getElementById('hp'),
    inv: document.getElementById('inv'),
    where: document.getElementById('where'),
    diff: document.getElementById('diff'),
    slots: document.getElementById('slotsHud'),
    mp: document.getElementById('mpHud')
  };
  const UI = {
    menu: document.getElementById('menu'),
    load: document.getElementById('load'),
    settings: document.getElementById('settings'),
    pause: document.getElementById('pause'),
    cutscene: document.getElementById('cutscene'),
    toast: document.getElementById('toast'),
    egg: document.getElementById('egg'),
    chat: document.getElementById('chat'),
    mp: document.getElementById('multiplayer'),
  };
  const BTN = {
    new: document.getElementById('btnNew'),
    load: document.getElementById('btnLoad'),
    settings: document.getElementById('btnSettings'),
    exit: document.getElementById('btnExit'),
    backFromLoad: document.getElementById('backFromLoad'),
    backFromSettings: document.getElementById('backFromSettings'),
    login: document.getElementById('btnLogin'),
    resume: document.getElementById('btnResume'),
    save: document.getElementById('btnSave'),
    mainMenu: document.getElementById('btnMainMenu'),
    mpOpen: document.getElementById('btnMultiplayer'),
    mpBack: document.getElementById('backFromMp'),
    mpHost: document.getElementById('btnHost'),
    mpJoin: document.getElementById('btnJoin'),
  };
  const ddDifficulty = document.getElementById('difficulty');
  const ddLang = document.getElementById('lang');
  const inputNick = document.getElementById('username');
  const chatInput = document.getElementById('chatInput');
  const joinCodeInput = document.getElementById('joinCode');
  const mpStatus = document.getElementById('mpStatus');
  const mpCodeEl = document.getElementById('mpCode');

  const TILE = 16;
  const W = canvas.width, H = canvas.height;

  // helpers
  const clamp=(v,a,b)=>Math.max(a,Math.min(b,v));
  const now=()=>performance.now();
  const toast=(msg,ms=1800)=>{ UI.toast.textContent=msg; UI.toast.classList.add('show'); setTimeout(()=>UI.toast.classList.remove('show'),ms); };
  const show=(el,on)=>{ el.style.display = on ? (el.classList.contains('menu') ? 'flex' : 'block') : 'none'; };
  const randCode=()=> Array.from({length:6},()=> "ABCDEFGHJKLMNPQRSTUVWXYZ23456789"[Math.floor(Math.random()*32)]).join('');

  // persistence
  const STORE_KEY = 'echo-ember-saves-v5';
  const defaultSaves = () => ({
    slots:[null,null,null],
    settings:{difficulty:'ok', lang:'de', nick:''},
    mp:{ enabled:false, mode:'', code:'' }
  });
  function loadAll(){ try{ return JSON.parse(localStorage.getItem(STORE_KEY))||defaultSaves(); }catch(e){ return defaultSaves(); } }
  function saveAll(data){ localStorage.setItem(STORE_KEY, JSON.stringify(data)); }

  let all = loadAll();
  ddDifficulty.value = all.settings?.difficulty || 'ok';
  ddLang.value = all.settings?.lang || 'de';
  inputNick.value = all.settings?.nick || '';

  // i18n
  const I18N = {
    de:{
      note:"3 Save-Slots. Hard = keine Saves + Permadeath.",
      loadTitle:"Laden / Neues Spiel",
      settings:"Einstellungen",
      paused:"Pause",
      pauseNote:"Hard deaktiviert Speichern.",
      lang:"Sprache",
      langNote:"UI + Meldungen.",
      diff:"Schwierigkeit",
      nick:"Nickname (lokal)",
      nickNote:"Wird nur im Browser gespeichert.",
      chatTitle:"Mini-Chat (R)",
      chatClose:"Esc zum Schließen",
      chatHint:"Tipp: Es gibt geheime Codes…",
      pickSlot:"Wähle einen Slot.",
      saved:"Gespeichert",
      hardNoSave:"HARD: Speichern deaktiviert.",
      deadSlot:"Slot ist DEAD. Starte 'New Here'.",
      need:"Du brauchst: ",
      locked:"Verschlossen. Schlüssel fehlt: ",
      portal:"Portal → ",
      win:"Sieg!",
      secret:"Geheimes Level…",
      introHint:"SPACE/E = weiter, ESC = skip",
      potionUsed:"Potion benutzt!",
      noPotion:"Keine Potion!",
      slotSel:"Slot gewählt: ",
      mpOn:"Multiplayer an (Prototype)",
    },
    en:{
      note:"3 save slots. Hard = no saves + permadeath.",
      loadTitle:"Load / Create Game",
      settings:"Settings",
      paused:"Paused",
      pauseNote:"Hard disables saving.",
      lang:"Language",
      langNote:"UI + messages.",
      diff:"Difficulty",
      nick:"Nickname (local)",
      nickNote:"Stored only in your browser.",
      chatTitle:"Mini Chat (R)",
      chatClose:"Esc to close",
      chatHint:"Tip: There are secret codes…",
      pickSlot:"Pick a slot.",
      saved:"Saved",
      hardNoSave:"HARD: Saving disabled.",
      deadSlot:"This slot is DEAD. Start New Here.",
      need:"You need: ",
      locked:"Locked. Missing key: ",
      portal:"Portal → ",
      win:"Victory!",
      secret:"Secret level…",
      introHint:"SPACE/E = next, ESC = skip",
      potionUsed:"Potion used!",
      noPotion:"No potion!",
      slotSel:"Selected slot: ",
      mpOn:"Multiplayer on (prototype)",
    },
    fr:{
      note:"3 emplacements. Difficile = pas de sauvegarde + mort définitive.",
      loadTitle:"Charger / Nouveau",
      settings:"Paramètres",
      paused:"Pause",
      pauseNote:"Difficile désactive la sauvegarde.",
      lang:"Langue",
      langNote:"Interface + messages.",
      diff:"Difficulté",
      nick:"Pseudo (local)",
      nickNote:"Stocké uniquement dans le navigateur.",
      chatTitle:"Mini Chat (R)",
      chatClose:"Esc pour fermer",
      chatHint:"Astuce : il y a des codes secrets…",
      pickSlot:"Choisis un slot.",
      saved:"Sauvegardé",
      hardNoSave:"DIFFICILE : sauvegarde désactivée.",
      deadSlot:"Ce slot est MORT. Lance 'New Here'.",
      need:"Il te faut : ",
      locked:"Fermé. Clé manquante : ",
      portal:"Portail → ",
      win:"Victoire !",
      secret:"Niveau secret…",
      introHint:"SPACE/E = suivant, ESC = skip",
      potionUsed:"Potion utilisée !",
      noPotion:"Pas de potion !",
      slotSel:"Slot choisi : ",
      mpOn:"Multijoueur activé (prototype)",
    }
  };
  const L = ()=> I18N[getLang()] || I18N.de;
  function getLang(){ return (loadAll().settings?.lang) || 'de'; }
  function getDiff(){ return (loadAll().settings?.difficulty) || 'ok'; }

  function applyLang(){
    const t = L();
    document.getElementById('tNote').textContent = t.note;
    document.getElementById('tLoadTitle').textContent = t.loadTitle;
    document.getElementById('tSettings').textContent = t.settings;
    document.getElementById('tPaused').textContent = t.paused;
    document.getElementById('tPauseNote').textContent = t.pauseNote;
    document.getElementById('tLang').textContent = t.lang;
    document.getElementById('tLangNote').textContent = t.langNote;
    document.getElementById('tDiff').textContent = t.diff;
    document.getElementById('tNick').textContent = t.nick;
    document.getElementById('tNickNote').textContent = t.nickNote;
    document.getElementById('tChatTitle').textContent = t.chatTitle;
    document.getElementById('tChatClose').textContent = t.chatClose;
    document.getElementById('tChatHint').textContent = t.chatHint;
    chatInput.placeholder = (getLang()==='de') ? "Tippe etwas und drücke Enter…" : (getLang()==='fr' ? "Tape et appuie sur Entrée…" : "Type and press Enter…");
  }
  applyLang();

  // input
  const keys=new Map();
  let chatOpen=false;

  function setKey(e,down){
    const k=e.key;
    keys.set(k.toLowerCase(),down);
    if(['ArrowUp','ArrowDown','ArrowLeft','ArrowRight'].includes(k)) keys.set(k,down);

    // pause toggle
    if((k==='t'||k==='T') && inGame && !chatOpen){
      togglePause();
      e.preventDefault();
    }

    // chat toggle
    if((k==='r'||k==='R') && inGame){
      if(down) toggleChat();
      e.preventDefault();
    }

    // esc close chat
    if(k==='Escape' && chatOpen && down){
      closeChat();
      e.preventDefault();
    }

    // select hotbar slots 1-5
    if(inGame && down && !chatOpen){
      if(['1','2','3','4','5'].includes(k)){
        selectSlot(parseInt(k,10)-1);
        e.preventDefault();
      }
      // quick potion
      if((k==='q'||k==='Q') && down){
        quickPotion();
        e.preventDefault();
      }
    }
  }
  window.addEventListener('keydown',e=>setKey(e,true));
  window.addEventListener('keyup',e=>setKey(e,false));

  // ================= MAPS =================
  // tile ids:
  // 0 floor
  // 1 wall
  // 2 rock
  // 4 stump
  // 5 decor
  // 6 decor
  // 7 portal tile
  // 8 gate marker
  // 10 ice
  // 11 dark floor
  // 12 sand
  const COLORS = {0:'#1c8c2d',1:'#3e4356',2:'#254070',4:'#865528',5:'#a7cc77',6:'#d7d7d7',7:'#6b76c8',8:'#9b0e0e',10:'#7aa6ff',11:'#0a0a10',12:'#b88b3d'};
  function makeMap(name, tiles, encounters){ return {name, w:20, h:12, tiles, encounters:encounters||[], npcs:[], chests:[], doors:[], bossDef:null, spawn:{x:2*TILE,y:2*TILE} }; }
  const isBlocked=id=> id===1 || id===2;
  const tileAt=(map,px,py)=>{ const tx=clamp(Math.floor(px/TILE),0,map.w-1), ty=clamp(Math.floor(py/TILE),0,map.h-1); return { id: map.tiles[ty*map.w+tx], x:tx, y:ty }; };

  // NEW: Castle / Intro Map
  const MAP_CASTLE = makeMap('Royal Castle',[
    1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,
    1,0,0,0,0,0,0,0,0,6,6,0,0,0,0,0,0,0,0,1,
    1,0,1,1,1,0,1,1,1,0,0,1,1,1,0,1,1,1,0,1,
    1,0,1,0,1,0,1,0,1,0,0,1,0,1,0,1,0,1,0,1,
    1,0,1,0,1,0,1,0,1,0,0,1,0,1,0,1,0,1,0,1,
    1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,
    1,0,1,0,1,0,1,0,1,1,1,0,1,0,1,0,1,0,0,1,
    1,0,1,0,1,0,1,0,0,0,0,0,1,0,1,0,1,0,0,1,
    1,0,0,0,0,0,0,0,1,1,1,0,0,0,0,0,0,0,0,1,
    1,0,0,0,1,1,1,0,1,0,1,0,1,1,1,0,0,0,0,1,
    1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,7,1,
    1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1
  ]);
  MAP_CASTLE.spawn = {x:2*TILE,y:9*TILE};

  // Existing overworld, cave, forest, frost, shadow, boss, secret
  const MAP_OVERWORLD = makeMap('Overworld',[
    1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,
    1,0,0,0,0,0,0,0,0,6,0,0,0,0,0,0,0,0,4,1,
    1,0,0,0,1,1,1,0,0,0,0,0,1,1,1,0,5,0,0,1,
    1,0,0,0,1,2,1,0,0,0,0,0,1,2,1,0,0,0,0,1,
    1,0,7,0,1,0,1,0,1,1,1,0,1,0,1,0,0,0,0,1,
    1,0,0,0,0,0,0,0,1,2,1,0,0,0,0,0,0,0,0,1,
    1,0,0,0,1,1,1,0,1,0,1,0,1,1,1,0,0,0,0,1,
    1,0,0,0,1,0,1,0,1,0,1,0,1,0,1,0,0,0,0,1,
    1,0,0,0,1,0,1,0,1,0,1,0,1,0,1,0,0,0,0,1,
    1,0,0,0,0,0,0,0,1,0,1,0,0,0,0,0,0,0,0,1,
    1,4,0,0,1,0,1,0,1,0,1,0,1,0,1,0,0,0,8,1,
    1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1
  ]);

  const MAP_CAVE = makeMap('Glimmer Caves',[
    1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,
    1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,7,1,
    1,0,1,1,1,0,1,1,1,0,1,1,1,0,1,1,1,0,0,1,
    1,0,1,5,1,0,1,6,1,0,1,5,1,0,1,6,1,0,0,1,
    1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,0,1,
    1,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,
    1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,0,1,
    1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,0,1,
    1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,
    1,0,0,0,1,1,1,0,1,0,1,0,1,1,1,0,0,0,0,1,
    1,7,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,4,1,
    1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1
  ]);

  const MAP_FOREST = makeMap('Forest Ruins',[
    1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,
    1,0,0,0,0,0,0,0,0,4,0,0,0,0,0,0,0,0,7,1,
    1,0,1,1,1,0,1,1,1,0,1,1,1,0,1,1,1,0,0,1,
    1,0,1,0,1,0,1,5,1,0,1,0,1,0,1,6,1,0,0,1,
    1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,0,1,
    1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,
    1,0,1,0,1,0,1,0,1,1,1,0,1,0,1,0,1,0,0,1,
    1,0,1,0,1,0,1,0,0,0,0,0,1,0,1,0,1,0,0,1,
    1,0,0,0,0,0,0,0,1,1,1,0,0,0,0,0,0,0,0,1,
    1,0,0,0,1,1,1,0,1,0,1,0,1,1,1,0,0,0,0,1,
    1,7,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,7,1,
    1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1
  ]);

  const MAP_FROST = makeMap('Frost Shrine',[
    1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,
    1,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,7,1,
    1,10,1,1,1,10,1,1,1,10,1,1,1,10,1,1,1,10,10,1,
    1,10,1,6,1,10,1,0,1,10,1,6,1,10,1,0,1,10,10,1,
    1,10,1,0,1,10,1,0,1,10,1,0,1,10,1,0,1,10,10,1,
    1,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,1,
    1,10,1,0,1,10,1,0,1,10,1,0,1,10,1,0,1,10,10,1,
    1,10,1,0,1,10,1,5,1,10,1,0,1,10,1,6,1,10,10,1,
    1,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,1,
    1,10,10,10,1,1,1,10,1,10,1,10,1,1,1,10,10,10,10,1,
    1,7,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,7,1,
    1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1
  ]);

  const MAP_SHADOW = makeMap('Shadow Nexus',[
    1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,
    1,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,7,1,
    1,11,1,1,1,11,1,1,1,11,1,1,1,11,1,1,1,11,11,1,
    1,11,1,0,1,11,1,0,1,11,1,0,1,11,1,0,1,11,11,1,
    1,11,1,0,1,11,1,0,1,11,1,0,1,11,1,0,1,11,11,1,
    1,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,1,
    1,11,1,0,1,11,1,0,1,11,1,0,1,11,1,0,1,11,11,1,
    1,11,1,0,1,11,1,0,1,11,1,0,1,11,1,0,1,11,11,1,
    1,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,1,
    1,11,11,11,1,1,1,11,1,11,1,11,1,1,1,11,11,11,11,1,
    1,7,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,7,1,
    1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1
  ]);

  const MAP_BOSS = makeMap('Boss Lair',[
    1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,
    1,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,1,
    1,11,1,1,1,11,1,1,1,11,1,1,1,11,1,1,1,11,11,1,
    1,11,1,0,1,11,1,0,1,11,1,0,1,11,1,0,1,11,11,1,
    1,11,1,0,1,11,1,0,1,11,1,0,1,11,1,0,1,11,11,1,
    1,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,1,
    1,11,1,0,1,11,1,0,1,11,1,0,1,11,1,0,1,11,11,1,
    1,11,1,0,1,11,1,0,1,11,1,0,1,11,1,0,1,11,11,1,
    1,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,1,
    1,11,11,11,1,1,1,11,1,11,1,11,1,1,1,11,11,11,11,1,
    1,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,1,
    1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1
  ]);

  const MAP_SECRET = makeMap('???',[
    1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,
    1,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,1,
    1,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,1,
    1,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,1,
    1,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,1,
    1,11,11,11,11,11,11,11,11,11,7,11,11,11,11,11,11,11,11,1,
    1,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,1,
    1,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,1,
    1,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,1,
    1,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,1,
    1,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,1,
    1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1
  ]);

  // NEW: extra endgame-ish map (Wastes) so you can expand further
  const MAP_WASTES = makeMap('Ash Wastes',[
    1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,
    1,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,7,1,
    1,12,1,1,1,12,1,1,1,12,1,1,1,12,1,1,1,12,12,1,
    1,12,1,0,1,12,1,0,1,12,1,0,1,12,1,0,1,12,12,1,
    1,12,1,0,1,12,1,0,1,12,1,0,1,12,1,0,1,12,12,1,
    1,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,1,
    1,12,1,0,1,12,1,0,1,12,1,0,1,12,1,0,1,12,12,1,
    1,12,1,0,1,12,1,0,1,12,1,0,1,12,1,0,1,12,12,1,
    1,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,1,
    1,12,12,12,1,1,1,12,1,12,1,12,1,1,1,12,12,12,12,1,
    1,7,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,7,1,
    1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1
  ]);

  function addDoor(a,x,y,b,tx,ty,opts={}){ a.doors.push({x,y,to:b,tx,ty, ...opts}); }

  // Door logic: AUTO on step (no E)
  addDoor(MAP_CASTLE,18,10,MAP_OVERWORLD,2,2,{label:'Overworld'});

  addDoor(MAP_OVERWORLD,2,4,MAP_CAVE,2,10,{label:'Caves'});
  addDoor(MAP_CAVE,18,1,MAP_OVERWORLD,18,9,{label:'Overworld'});

  addDoor(MAP_CAVE,1,1,MAP_FOREST,2,10,{label:'Forest', requireKey:'key1'});
  addDoor(MAP_FOREST,18,1,MAP_CAVE,2,2,{label:'Caves'});

  addDoor(MAP_FOREST,18,10,MAP_FROST,2,10,{label:'Frost', requireKey:'key2'});
  addDoor(MAP_FROST,1,10,MAP_FOREST,17,2,{label:'Forest'});

  addDoor(MAP_FROST,18,1,MAP_SHADOW,2,10,{label:'Shadow', requireKey:'key3'});
  addDoor(MAP_SHADOW,1,10,MAP_FROST,17,2,{label:'Frost'});

  addDoor(MAP_SHADOW,18,10,MAP_BOSS,2,9,{label:'Boss', requireItems:['bow','shield']});
  addDoor(MAP_BOSS,1,9,MAP_SHADOW,17,2,{label:'Shadow'});

  // NEW progression extension (after final door area you can add more content)
  addDoor(MAP_BOSS,18,1,MAP_WASTES,2,10,{label:'Wastes', requireItems:['bow','shield']});
  addDoor(MAP_WASTES,1,10,MAP_BOSS,17,2,{label:'Boss Lair'});

  // Secret
  addDoor(MAP_SECRET,10,5,MAP_SECRET,10,5,{label:'Secret Portal', secretPortal:true});

  // CONTENT: chests & NPCs & encounters
  MAP_OVERWORLD.encounters=[{x:6,y:5,type:'slime'},{x:14,y:6,type:'slime'},{x:3,y:8,type:'slime'}];
  MAP_OVERWORLD.chests.push({x:16,y:2,item:'key1',opened:false});
  MAP_OVERWORLD.npcs.push({x:9,y:1,text:"Find keys. In the caves: sword and bow."});

  MAP_CAVE.encounters=[{x:5,y:5,type:'bat'},{x:15,y:5,type:'bat'}];
  MAP_CAVE.chests.push({x:11,y:3,item:'sword',opened:false});
  MAP_CAVE.chests.push({x:16,y:9,item:'bow',opened:false});
  MAP_CAVE.chests.push({x:3,y:3,item:'potion',opened:false});
  MAP_CAVE.npcs.push({x:7,y:3,text:"Hotbar: 1-5 select. Space uses selected."});

  MAP_FOREST.encounters=[{x:6,y:5,type:'slime'},{x:14,y:7,type:'slime'},{x:10,y:5,type:'bandit'}];
  MAP_FOREST.chests.push({x:7,y:3,item:'potion',opened:false});
  MAP_FOREST.npcs.push({x:7,y:10,text:"A corrupted guardian hides deeper in these ruins…"});
  MAP_FOREST.bossDef = { id:'boss1', name:'Root Warden', x: 13*TILE, y: 6*TILE };

  MAP_FROST.encounters=[{x:6,y:5,type:'bat'},{x:14,y:5,type:'bandit'}];
  MAP_FROST.chests.push({x:7,y:7,item:'shield',opened:false});
  MAP_FROST.chests.push({x:15,y:3,item:'potion',opened:false});
  MAP_FROST.bossDef = { id:'boss2', name:'Ice Sentinel', x: 13*TILE, y: 6*TILE };

  MAP_SHADOW.encounters=[{x:10,y:5,type:'bandit'},{x:14,y:7,type:'emberling'}];
  MAP_SHADOW.npcs.push({x:7,y:3,text:"Final door: bow + shield. ENTER blocks. SPACE uses selected slot."});

  MAP_BOSS.bossDef = { id:'boss3', name:'Ash Tyrant', x: 12*TILE, y: 5*TILE };

  MAP_WASTES.encounters=[{x:10,y:5,type:'emberling'},{x:14,y:7,type:'emberling'}];
  MAP_WASTES.chests.push({x:15,y:3,item:'potion',opened:false});
  MAP_WASTES.npcs.push({x:6,y:9,text:"More lands ahead… build more maps here."});

  // ================= PLAYER / STATE =================
  function makePlayer(){
    return {
      x:2*TILE,y:2*TILE,w:12,h:12,
      dir:1,
      hp:10,hpMax:10,

      // "logical" inventory (keys, etc.)
      inv:[],

      // NEW: 5-slot hotbar (items you can select/use)
      hotbar:[null,null,null,null,null],
      selectedSlot:0,
      potions:0, // stack count

      map:MAP_CASTLE,
      slot:0,
      name:'',
      hasWon:false,
      iFrames:0,
      blocking:false,
      blockTimer:0,
      lastArrow:0,
      checkpoint:{ mapName:'Royal Castle', x:2*TILE, y:9*TILE },
      speech:{ text:'', timer:0 }
    };
  }
  let player = makePlayer();

  // optional local coop second player (enabled when MP is enabled)
  function makePlayer2(){
    return {
      x:3*TILE,y:9*TILE,w:12,h:12,
      dir:1,
      hp:10,hpMax:10,
      hotbar:[null,null,null,null,null],
      selectedSlot:0,
      potions:0,
      alive:true,
    };
  }
  let p2 = makePlayer2();

  const DIFF = {
    easy:{ enemyHp:3, enemyDmg:1, bossHp1:18, bossHp2:22, bossHp3:34, bossDmg:2, fire:2, respawn:true },
    ok:  { enemyHp:5, enemyDmg:2, bossHp1:24, bossHp2:28, bossHp3:44, bossDmg:3, fire:3, respawn:true },
    hard:{ enemyHp:7, enemyDmg:3, bossHp1:30, bossHp2:34, bossHp3:56, bossDmg:4, fire:4, respawn:false }
  };
  const D = ()=> DIFF[getDiff()] || DIFF.ok;

  const has=item=> player.inv.includes(item);

  function autoEquip(item){
    // first free slot
    const i = player.hotbar.findIndex(s=>s===null);
    if(i>=0){ player.hotbar[i]=item; }
  }

  function ensureInHotbar(item, preferredIndex){
    // if already in hotbar, skip
    if(player.hotbar.includes(item)) return;
    if(typeof preferredIndex==='number' && preferredIndex>=0 && preferredIndex<player.hotbar.length){
      if(player.hotbar[preferredIndex]===null){
        player.hotbar[preferredIndex]=item;
        return;
      }
    }
    autoEquip(item);
  }

  function grant(item){
    if(item==='potion'){
      player.potions++;
      ensureInHotbar('potion', 2); // slot 3 preferred
      toast(`+ potion (${player.potions})`);
      return;
    }
    if(!has(item)){
      player.inv.push(item);
      toast(`+ ${item}`);
      // auto equip weapons
      if(item==='sword') ensureInHotbar('sword', 0);
      if(item==='bow') ensureInHotbar('bow', 1);
      // shield is passive (block), but you can still show it in hotbar if you want:
      if(item==='shield') { /* optional: ensureInHotbar('shield', 3); */ }

      if(item==='bow' || item==='shield') setCheckpoint();
    }
  }

  function setCheckpoint(){
    player.checkpoint = { mapName: player.map.name, x: player.x, y: player.y };
  }

  function selectSlot(i){
    player.selectedSlot = clamp(i,0,4);
    toast(L().slotSel + (player.selectedSlot+1));
  }

  function quickPotion(){
    if(player.potions<=0){ toast(L().noPotion); return; }
    player.potions--;
    player.hp = Math.min(player.hpMax, player.hp+5);
    toast(L().potionUsed);
    if(player.potions<=0){
      // remove potion from hotbar if no stack left
      for(let i=0;i<player.hotbar.length;i++){
        if(player.hotbar[i]==='potion') player.hotbar[i]=null;
      }
    }
  }

  // ================= ENTITIES =================
  const overlap=(a,b)=> !(a.x+a.w<b.x || b.x+b.w<a.x || a.y+a.h<b.y || b.y+b.h<a.y);
  function moveEntity(e,dx,dy){
    const map=player.map;
    const nx=e.x+dx, ny=e.y+dy;
    const corners=[ tileAt(map,nx,ny), tileAt(map,nx+e.w,ny), tileAt(map,nx,ny+e.h), tileAt(map,nx+e.w,ny+e.h) ];
    if(corners.some(c=>isBlocked(c.id))) return;
    e.x=nx; e.y=ny;
  }

  function makeEnemy(type,x,y){
    const d=D();
    const e={x,y,w:12,h:12,type,hp:d.enemyHp,alive:true,dmg:d.enemyDmg,lastHit:0};
    if(type==='bat'){ e.w=10;e.h=10; }
    if(type==='emberling'){ e.hp+=2; e.dmg+=1; }
    if(type==='bandit'){ e.hp+=3; e.dmg+=2; }
    return e;
  }
  function spawnForMap(map){
    return map.encounters
      .filter(en => en.type!=='bandit' || has('bow'))
      .map(en=> makeEnemy(en.type, en.x*TILE+2, en.y*TILE+2));
  }
  let enemies = spawnForMap(player.map);

  // projectiles
  const arrows=[];
  const fireballs=[];

  function shootArrow(who){
    // who: player (default) or p2
    const src = who || player;
    if(!has('bow')) return;
    const t=now();
    if(t-player.lastArrow<280) return;
    player.lastArrow=t;
    const speed=140;
    arrows.push({
      x: src.x + (src.dir===1 ? src.w+1 : -3),
      y: src.y + 5,
      w:3,h:2,
      vx: (src.dir===1? speed : -speed),
      vy:0,
      life: 1200
    });
  }

  // Boss system
  let bosses = { boss1: null, boss2: null, boss3: null, finalPhase: 1 };
  const bossAlive = (b)=> b && b.alive;

  function spawnBoss(id, map){
    const d=D();
    const def = map.bossDef;
    if(!def || def.id!==id) return null;

    let hp = d.bossHp3, dmg = d.bossDmg, kind='final';
    if(id==='boss1'){ hp=d.bossHp1; dmg=d.bossDmg-1; kind='root'; }
    if(id==='boss2'){ hp=d.bossHp2; dmg=d.bossDmg; kind='ice'; }
    if(id==='boss3'){ hp=d.bossHp3; dmg=d.bossDmg+1; kind='ash'; }

    return {
      id, kind,
      x:def.x, y:def.y, w:(id==='boss3'?24:18), h:(id==='boss3'?20:16),
      hp, hpMax:hp, dmg,
      alive:true, lastHit:0, lastFire:0, lastDash:0
    };
  }

  function ensureBossForMap(map){
    if(!map.bossDef) return;
    const id = map.bossDef.id;
    if(!bosses[id]) bosses[id] = spawnBoss(id, map);
  }

  function bossFire(b){
    const t=now();
    const cd = (b.id==='boss3') ? (b.hp < b.hpMax*0.55 ? 650 : 950) : 1200;
    if(t-b.lastFire<cd) return;
    b.lastFire=t;

    const dx=(player.x-b.x), dy=(player.y-b.y);
    const len=Math.max(1, Math.hypot(dx,dy));
    const speed = (b.id==='boss3') ? 105 : 85;

    fireballs.push({x:b.x+b.w/2,y:b.y+b.h/2,w:4,h:4,vx:(dx/len)*speed,vy:(dy/len)*speed,life:2200, from:b.id});
  }

  function bossAI(b, dt){
    if(!b.alive) return;
    const t=now();
    const s = (b.id==='boss3' ? 30 : 34) * dt;

    moveEntity(b, Math.sign(player.x-b.x)*s, Math.sign(player.y-b.y)*s);

    if(overlap(b,player) && (t-b.lastHit)>520){
      b.lastHit=t;
      damagePlayer(b.dmg, 'hit');
    }

    if(b.id==='boss1'){
      if(t-b.lastDash>1400){
        b.lastDash=t;
        moveEntity(b, Math.sign(player.x-b.x)*18, Math.sign(player.y-b.y)*18);
      }
    }
    if(b.id==='boss2'){
      if(t-b.lastFire>900) bossFire(b);
    }
    if(b.id==='boss3'){
      bossFire(b);
      if(bosses.finalPhase===2 && t-b.lastDash>1200){
        b.lastDash=t;
        moveEntity(b, Math.sign(player.x-b.x)*22, Math.sign(player.y-b.y)*22);
      }
    }
  }

  // ================= DRAW =================
  const rect=(x,y,w,h,c)=>{ ctx.fillStyle=c; ctx.fillRect(x,y,w,h); };

  function drawMap(map){
    for(let y=0;y<map.h;y++){
      for(let x=0;x<map.w;x++){
        const id=map.tiles[y*map.w+x];
        let c=COLORS[id]||'#222';

        if(id===0 && map===MAP_OVERWORLD) c = (((x+y)&1)? '#187528':'#1f9a34');
        if(id===0 && map===MAP_CAVE) c = (((x+y)&1)? '#1b2030':'#1f2538');
        if(id===0 && map===MAP_FOREST) c = (((x+y)&1)? '#245a2d':'#2d7336');
        if(id===0 && map===MAP_FROST) c = (((x+y)&1)? '#1b2a3f':'#203252');
        if(id===0 && map===MAP_CASTLE) c = (((x+y)&1)? '#1e2438':'#232b44');
        if(id===0 && map===MAP_WASTES) c = (((x+y)&1)? '#6b4a1d':'#7a5521');
        if(id===0 && (map===MAP_SHADOW||map===MAP_BOSS||map===MAP_SECRET)) c = (((x+y)&1)? '#07070c':'#0c0c14');
        if(id===10) c = (((x+y)&1)? '#6f9cff':'#86b0ff');
        if(id===11) c = (((x+y)&1)? '#06060a':'#0a0a10');
        if(id===12) c = (((x+y)&1)? '#b88b3d':'#c49a4a');

        rect(x*TILE,y*TILE,TILE,TILE,c);

        if(id===5){ rect(x*TILE+4,y*TILE+4,8,8,'#c93'); rect(x*TILE+4,y*TILE+6,8,4,'#642'); }
        if(id===6){ rect(x*TILE+2,y*TILE+6,12,4,'#bbb'); }
        if(id===4){ rect(x*TILE+4,y*TILE+4,8,8,'#543'); }
        if(id===7){ rect(x*TILE+3,y*TILE+3,10,10,'#6b76c8'); rect(x*TILE+5,y*TILE+5,6,6,'#0b0e14'); }
        if(id===8){ rect(x*TILE+2,y*TILE+2,12,12,'#410'); rect(x*TILE+5,y*TILE+5,6,6,'#900'); }
      }
    }
  }

  function drawPlayerBase(p, color){
    rect(p.x-1,p.y-1,p.w+2,p.h+2,'#000');
    rect(p.x,p.y,p.w,p.h, color);

    if(p.dir===-1) rect(p.x+2,p.y+4,3,3,'#111'); else rect(p.x+7,p.y+4,3,3,'#111');
  }

  function drawPlayer(){
    drawPlayerBase(player, player.blocking ? '#cfe6ff':'#eaeaea');

    // weapon visuals based on selected slot
    const sel = player.hotbar[player.selectedSlot];
    if(sel==='sword'){
      if(player.dir===1) rect(player.x+player.w, player.y+3, 6,2, '#ddd');
      else rect(player.x-6, player.y+3, 6,2, '#ddd');
    }
    if(sel==='bow'){
      const bx = (player.dir===1? player.x+player.w-1 : player.x-2);
      rect(bx, player.y+2, 2, 9, '#b5853a');
      rect(bx+(player.dir===1? 1:-1), player.y+2, 1, 9, '#e8f0ff');
    }
    if(has('shield') && player.blocking){
      const sx = (player.dir===1? player.x+player.w : player.x-5);
      rect(sx, player.y+3, 5, 7, '#6b76c8');
      rect(sx+1, player.y+4, 3, 5, '#0b0e14');
    }

    // speech bubble
    if(player.speech.timer>0 && player.speech.text){
      const text = player.speech.text.slice(0,40);
      const bw = Math.min(180, 10 + text.length*6);
      const bx = clamp(player.x - bw/2 + player.w/2, 2, W-bw-2);
      const by = clamp(player.y - 18, 2, H-18);
      rect(bx-1,by-1,bw+2,14+2,'#000');
      rect(bx,by,bw,14,'#0b1124');
      ctx.fillStyle = '#e8f0ff';
      ctx.font = '10px ui-monospace, monospace';
      ctx.fillText(text, bx+6, by+10);
    }
  }

  function drawPlayer2(){
    if(!mp.enabled) return;
    drawPlayerBase(p2, '#d6c08a');
  }

  function drawEnemies(){
    enemies.forEach(e=>{
      if(!e.alive) return;
      let color='#39f';
      if(e.type==='bat') color='#bbb';
      if(e.type==='emberling') color='#f64';
      if(e.type==='bandit') color='#d6c08a';
      rect(e.x-1,e.y-1,e.w+2,e.h+2,'#000');
      rect(e.x,e.y,e.w,e.h,color);
      if(e.type==='bandit') rect(e.x+e.w,e.y+4,6,2,'#ddd');
    });
  }

  function drawProjectiles(){
    arrows.forEach(a=>{ rect(a.x-1,a.y-1,a.w+2,a.h+2,'#000'); rect(a.x,a.y,a.w,a.h,'#e8f0ff'); });
    fireballs.forEach(f=>{ rect(f.x-1,f.y-1,f.w+2,f.h+2,'#000'); rect(f.x,f.y,f.w,f.h,'#ff6a3a'); rect(f.x+1,f.y+1,2,2,'#ffd27a'); });
  }

  function drawBoss(b){
    if(!b || !b.alive) return;
    rect(b.x-2,b.y-2,b.w+4,b.h+4,'#000');

    let body='#3a0b0f', inner='#6a1119', eye='#ffd27a';
    if(b.id==='boss1'){ body='#243a1b'; inner='#2d7336'; eye='#e8f0ff'; }
    if(b.id==='boss2'){ body='#142642'; inner='#203252'; eye='#7aa6ff'; }

    rect(b.x,b.y,b.w,b.h,body);
    rect(b.x+2,b.y+2,b.w-4,b.h-4,inner);

    rect(b.x+5,b.y+6,4,3,eye);
    rect(b.x+b.w-9,b.y+6,4,3,eye);

    const bw = b.w;
    const hpw = Math.max(0, Math.floor((b.hp/b.hpMax)*bw));
    rect(b.x, b.y-6, bw, 3, '#0b0e14');
    rect(b.x, b.y-6, hpw, 3, '#00f6c7');
  }

  // ================= COMBAT / USE =================
  function damagePlayer(n, source='hit'){
    if(player.iFrames>0) return;

    if(player.blocking && has('shield')){
      n *= (source==='fire') ? 0.15 : 0.35;
      if(n < 0.2){ toast('Blocked!'); return; }
      toast('Blocked (reduced)!');
    }

    player.hp -= n;
    player.iFrames = 360;
    if(player.hp<=0){ player.hp=0; onDeath(); }
  }

  function meleeHitbox(p){
    const who = p || player;
    return { x: who.x + (who.dir===1? who.w:-8), y: who.y+2, w:8, h:8 };
  }

  function attackEntityMelee(target){
    const range=meleeHitbox(player);
    if(overlap(range,target)){
      target.hp--;
      if(target.hp<=0) target.alive=false;
      target.lastHit=now();
    }
  }

  function handleArrowHits(){
    for(const a of arrows){
      enemies.forEach(e=>{
        if(e.alive && overlap(a,e)){
          e.hp -= 1;
          if(e.hp<=0) e.alive=false;
          a.life=0;
        }
      });

      const bs = [bosses.boss1, bosses.boss2, bosses.boss3];
      for(const b of bs){
        if(b && b.alive && overlap(a,b)){
          b.hp -= 1;
          a.life=0;
        }
      }
    }
  }

  function useSelected(){
    const sel = player.hotbar[player.selectedSlot];
    if(!sel) return;

    // potion use as selected
    if(sel==='potion'){
      quickPotion();
      return;
    }

    // sword melee
    if(sel==='sword'){
      enemies.forEach(e=> e.alive && attackEntityMelee(e));
      if(player.map.bossDef){
        const id = player.map.bossDef.id;
        const b = bosses[id];
        if(b && b.alive && id!=='boss3') attackEntityMelee(b);
      }
      if(player.map===MAP_BOSS && bosses.finalPhase===2){
        if(bossAlive(bosses.boss1)) attackEntityMelee(bosses.boss1);
        if(bossAlive(bosses.boss2)) attackEntityMelee(bosses.boss2);
      }
      return;
    }

    // bow shoot
    if(sel==='bow'){
      shootArrow(player);
      return;
    }
  }

  // ================= GAME LOOP =================
  let last=0, dt=0, paused=false, inGame=false, transitioning=false;
  let cutsceneActive=false;

  function togglePause(){
    if(chatOpen) return;
    paused=!paused;
    UI.pause.classList.toggle('active', paused);
    BTN.save.disabled = (getDiff()==='hard');
  }

  function render(){
    ctx.imageSmoothingEnabled=false;
    ctx.clearRect(0,0,W,H);

    drawMap(player.map);
    drawEnemies();

    if(player.map.bossDef){
      const id = player.map.bossDef.id;
      drawBoss(bosses[id]);
    }
    if(player.map===MAP_BOSS && bosses.finalPhase===2){
      drawBoss(bosses.boss1);
      drawBoss(bosses.boss2);
      drawBoss(bosses.boss3);
    }

    drawProjectiles();
    drawPlayer2();
    drawPlayer();

    // HUD
    HUD.hp.textContent = `HP: ${Math.max(0,player.hp).toFixed(0)}/${player.hpMax}`;
    HUD.inv.textContent = `Inv: ${player.inv.join(', ')||'None'} · Potions: ${player.potions}`;
    let bossInfo = '';
    if(player.map===MAP_BOSS && bosses.boss3){
      bossInfo = ` · Final P${bosses.finalPhase}`;
    }
    HUD.where.textContent = `Area: ${player.map.name}${bossInfo}`;
    HUD.diff.textContent = `Diff: ${getDiff().toUpperCase()}`;

    const slotLabel = player.hotbar.map((it,i)=>{
      const s = it ? it : '—';
      const mark = (i===player.selectedSlot) ? '*' : '';
      return `${i+1}${mark}:${s}`;
    }).join('  ');
    HUD.slots.textContent = `Slots: ${slotLabel}`;

    if(mp.enabled){
      HUD.mp.style.display='block';
      HUD.mp.textContent = `MP: ${mp.mode.toUpperCase()} · Code ${mp.code}`;
    } else {
      HUD.mp.style.display='none';
    }
  }

  let sayTimer=0;
  function say(html, ms=1400){
    UI.cutscene.innerHTML = html;
    show(UI.cutscene,true);
    clearTimeout(sayTimer);
    sayTimer=setTimeout(()=>show(UI.cutscene,false), ms);
  }

  function update(t){
    dt=(t-last)/1000; last=t;

    if(!inGame || paused || chatOpen || cutsceneActive){
      requestAnimationFrame(update);
      return;
    }

    player.iFrames = Math.max(0, player.iFrames - dt*1000);
    player.blockTimer = Math.max(0, player.blockTimer - dt*1000);
    if(player.blockTimer<=0) player.blocking=false;

    if(player.speech.timer>0){
      player.speech.timer -= dt*1000;
      if(player.speech.timer<=0){ player.speech.timer=0; player.speech.text=''; }
    }

    // block enter
    if((keys.get('enter') || keys.get('Enter')) && has('shield')){
      player.blocking=true;
      player.blockTimer=140;
    }

    // movement p1
    const sp=75;
    let dx=0,dy=0;
    if(keys.get('a')||keys.get('arrowleft')){ dx-=sp*dt; player.dir=-1; }
    if(keys.get('d')||keys.get('arrowright')){ dx+=sp*dt; player.dir= 1; }
    if(keys.get('w')||keys.get('arrowup')){ dy-=sp*dt; }
    if(keys.get('s')||keys.get('arrowdown')){ dy+=sp*dt; }
    if(dx!==0) moveEntity(player,dx,0);
    if(dy!==0) moveEntity(player,0,dy);

    // movement p2 (local coop) - IJKL
    if(mp.enabled){
      let dx2=0,dy2=0;
      const sp2=72;
      if(keys.get('j')){ dx2-=sp2*dt; p2.dir=-1; }
      if(keys.get('l')){ dx2+=sp2*dt; p2.dir= 1; }
      if(keys.get('i')){ dy2-=sp2*dt; }
      if(keys.get('k')){ dy2+=sp2*dt; }
      if(dx2!==0) moveEntity(p2,dx2,0);
      if(dy2!==0) moveEntity(p2,0,dy2);
    }

    // frost chip damage
    const ct = tileAt(player.map, player.x+player.w/2, player.y+player.h/2);
    if(player.map===MAP_FROST && ct.id===10){
      damagePlayer(0.9*dt,'hit');
      if(dx!==0) moveEntity(player, dx*0.35, 0);
      if(dy!==0) moveEntity(player, 0, dy*0.35);
    }

    // use/attack (SPACE) -> uses selected item
    if(keys.get(' ')){
      useSelected();
    }

    // enemies chase (target player1)
    enemies.forEach(e=>{
      if(!e.alive) return;
      const s = (e.type==='bandit'? 44:38)*dt;
      moveEntity(e, Math.sign(player.x-e.x)*s, Math.sign(player.y-e.y)*s);
      const cd = (e.type==='bandit'? 380:450);
      if(overlap(e,player) && (now()-e.lastHit)>cd){
        e.lastHit=now();
        damagePlayer(e.dmg,'hit');
      }
    });

    // bosses
    ensureBossForMap(player.map);

    if(player.map.bossDef){
      const id = player.map.bossDef.id;
      const b = bosses[id];
      if(b && b.alive){
        bossAI(b, dt);
      }
      if(b && !b.alive && !b._dropped){
        b._dropped=true;
        if(id==='boss1'){ grant('key2'); toast('+ key2'); }
        if(id==='boss2'){ grant('key3'); toast('+ key3'); }
        if(id==='boss3'){
          if(bosses.finalPhase===1){
            bosses.finalPhase=2;
            toast('FINAL: PHASE 2!');
            bosses.boss1 = bosses.boss1 && bosses.boss1.alive ? bosses.boss1 : { ...spawnBoss('boss1', MAP_FOREST), x: 7*TILE, y: 4*TILE };
            bosses.boss2 = bosses.boss2 && bosses.boss2.alive ? bosses.boss2 : { ...spawnBoss('boss2', MAP_FROST), x: 7*TILE, y: 8*TILE };
            bosses.boss3 = { ...spawnBoss('boss3', MAP_BOSS), hp: Math.floor(D().bossHp3*0.75), hpMax: Math.floor(D().bossHp3*0.75) };
          } else {
            player.hasWon=true;
            ending();
          }
        }
      }
    }

    if(player.map===MAP_BOSS && bosses.finalPhase===2){
      [bosses.boss1,bosses.boss2,bosses.boss3].forEach(b=> b && b.alive && bossAI(b, dt));
      if((!bossAlive(bosses.boss1)) && (!bossAlive(bosses.boss2)) && (!bossAlive(bosses.boss3))){
        player.hasWon=true;
        ending();
      }
    }

    // projectiles
    arrows.forEach(a=>{
      a.x+=a.vx*dt; a.y+=a.vy*dt; a.life-=dt*1000;
      const ta=tileAt(player.map,a.x,a.y);
      if(isBlocked(ta.id)) a.life=0;
    });
    fireballs.forEach(f=>{
      f.x+=f.vx*dt; f.y+=f.vy*dt; f.life-=dt*1000;
      const tf=tileAt(player.map,f.x,f.y);
      if(isBlocked(tf.id)) f.life=0;
      if(overlap(f,player)){
        damagePlayer(D().fire,'fire');
        f.life=0;
      }
    });

    handleArrowHits();
    for(let i=arrows.length-1;i>=0;i--) if(arrows[i].life<=0) arrows.splice(i,1);
    for(let i=fireballs.length-1;i>=0;i--) if(fireballs[i].life<=0) fireballs.splice(i,1);

    handleTilesAuto();
    render();
    requestAnimationFrame(update);
  }

  // ================= TILE INTERACTIONS =================
  // NEW: portals auto-trigger on step (no E)
  function handleTilesAuto(){
    const center={x:player.x+player.w/2, y:player.y+player.h/2};
    const t=tileAt(player.map, center.x, center.y);

    // chests auto-open on touch
    (player.map.chests||[]).forEach(ch=>{
      if(ch.opened) return;
      const box={x:ch.x*TILE+2,y:ch.y*TILE+2,w:12,h:12};
      if(overlap({x:center.x-1,y:center.y-1,w:2,h:2}, box)){
        ch.opened=true;
        if(ch.item==='potion'){
          grant('potion');
        } else {
          grant(ch.item);
        }
      }
    });

    // npcs: talk when touching
    (player.map.npcs||[]).forEach(n=>{
      const box={x:n.x*TILE+1,y:n.y*TILE+1,w:14,h:14};
      if(overlap({x:center.x-1,y:center.y-1,w:2,h:2}, box)){
        say(`<span class="name">NPC</span>: ${n.text}`, 1100);
      }
    });

    // portals auto step
    (player.map.doors||[]).forEach(d=>{
      if(t.x===d.x && t.y===d.y){
        if(transitioning) return;

        if(d.secretPortal){
          secretCutscene();
          return;
        }

        if(d.requireKey && !has(d.requireKey)){
          say(L().locked + d.requireKey, 900);
          return;
        }
        if(d.requireItems && d.requireItems.some(it=>!has(it))){
          say(L().need + d.requireItems.join(' + '), 900);
          return;
        }

        setCheckpoint();
        changeMap(d.to, d.tx, d.ty);
        toast(L().portal + d.label);
      }
    });
  }

  function fade(after){
    let a=1;
    const step=()=>{
      ctx.fillStyle=`rgba(0,0,0,${a})`;
      ctx.fillRect(0,0,W,H);
      a-=0.08;
      if(a>0) requestAnimationFrame(step);
      else after();
    };
    step();
  }

  function changeMap(map, tx, ty){
    if(transitioning) return;
    transitioning=true;
    fade(()=>{
      player.map=map;
      enemies=spawnForMap(map);
      player.x=tx*TILE+2;
      player.y=ty*TILE+2;
      arrows.length=0; fireballs.length=0;
      transitioning=false;

      if(map===MAP_BOSS && bosses.finalPhase===1 && !bosses.boss3){
        bosses.boss3 = spawnBoss('boss3', MAP_BOSS);
      }
    });
  }

  // ================= END / DEATH / RESPAWN =================
  function ending(){
    paused=true;
    UI.pause.classList.remove('active');
    show(UI.cutscene,true);
    UI.cutscene.innerHTML = `<b>${L().win}</b><br/>Phase complete. Press <b>T</b> then Main Menu.`;
  }

  function markSlotDead(){
    all = loadAll();
    const idx = player.slot||0;
    const existing = all.slots[idx] || {};
    all.slots[idx] = {
      ...existing,
      dead:true,
      name: existing.name || player.name || '',
      ts: Date.now(),
      map: player.map?.name || 'Overworld',
      hp: 0, hpMax: player.hpMax,
      inv: player.inv || [],
      hotbar: player.hotbar || [],
      potions: player.potions || 0,
      hasWon:false,
      x: player.x, y: player.y
    };
    saveAll(all);
  }

  function onDeath(){
    const hard = getDiff()==='hard';
    paused=true;
    UI.pause.classList.add('active');
    if(hard){
      say(`<b>${L().permadeath || 'Permadeath!'}</b>`, 1300);
      markSlotDead();
      setTimeout(()=>returnToMenu(), 900);
      return;
    }
    say("You died…", 900);
    setTimeout(()=>respawn(), 650);
  }

  function respawn(){
    const cp = player.checkpoint || {mapName:'Royal Castle', x:2*TILE, y:9*TILE};
    const mapByName=(n)=>{
      if(n==='Royal Castle') return MAP_CASTLE;
      if(n==='Glimmer Caves') return MAP_CAVE;
      if(n==='Forest Ruins') return MAP_FOREST;
      if(n==='Frost Shrine') return MAP_FROST;
      if(n==='Shadow Nexus') return MAP_SHADOW;
      if(n==='Boss Lair') return MAP_BOSS;
      if(n==='Ash Wastes') return MAP_WASTES;
      if(n==='???') return MAP_SECRET;
      return MAP_OVERWORLD;
    };
    player.map = mapByName(cp.mapName);
    player.x = cp.x; player.y = cp.y;
    player.hp = player.hpMax;
    player.iFrames = 600;
    enemies = spawnForMap(player.map);
    arrows.length=0; fireballs.length=0;
    paused=false;
    UI.pause.classList.remove('active');
    toast('Respawn!');
  }

  // ================= SECRET CUTSCENE =================
  function secretCutscene(){
    paused=true;
    UI.pause.classList.remove('active');
    show(UI.cutscene,true);
    UI.cutscene.innerHTML =
      `<b>Secret Cutscene</b><br/><br/>
      <span class="name">Developer</span>: Ferris<br/>
      <span class="name">Easter Eggs / Codes</span>:<br/>
      - BLOCK-BLOCK (gives Shield)<br/>
      - ROW-ROW-BOW (gives Bow)<br/>
      - WIN-WIN-WIN (instant win)<br/>
      - End-End (secret dimension)<br/><br/>
      Press <b>T</b> then Main Menu.`;
  }

  // ================= INTRO STORY CUTSCENE =================
  const introLines = [
    {name:'King', text:'Hero… our kingdom is finally at peace.'},
    {name:'Princess', text:'Thank you for protecting the Ember Flame.'},
    {name:'???', text:'Peace? How adorable.'},
    {name:'Endlos', text:'I am ENDLOS. I devour worlds.'},
    {name:'King', text:'Guards—!'},
    {name:'Endlos', text:'Too late.'},
    {name:'Narrator', text:'The castle fractures. The flame dims. You survive… barely.'},
    {name:'Princess', text:'Find the keys… rebuild the Ember… stop Endlos…'}
  ];
  let introIndex=0;

  function startIntro(){
    cutsceneActive=true;
    introIndex=0;
    show(UI.cutscene,true);
    renderIntroLine();
  }
  function renderIntroLine(){
    const line = introLines[introIndex];
    UI.cutscene.innerHTML = `<span class="name">${line.name}</span>: ${line.text}<div class="small">${L().introHint}</div>`;
  }
  function endIntro(){
    cutsceneActive=false;
    show(UI.cutscene,false);
    // after story: auto go from castle spawn -> portal exists at (18,10)
    toast('Go to the portal…');
  }

  window.addEventListener('keydown', (e)=>{
    if(!inGame) return;
    if(!cutsceneActive) return;
    if(e.key==='Escape'){
      cutsceneActive=false;
      show(UI.cutscene,false);
      return;
    }
    if(e.key===' ' || e.key==='Enter' || e.key==='e' || e.key==='E'){
      introIndex++;
      if(introIndex>=introLines.length){
        endIntro();
      } else renderIntroLine();
      e.preventDefault();
    }
  });

  // ================= MINI CHAT (R) =================
  function toggleChat(){
    chatOpen = !chatOpen;
    UI.chat.classList.toggle('active', chatOpen);
    if(chatOpen){
      chatInput.value='';
      chatInput.focus();
    } else {
      chatInput.blur();
    }
  }
  function closeChat(){
    chatOpen=false;
    UI.chat.classList.remove('active');
    chatInput.blur();
  }

  function speak(text){
    player.speech.text = text;
    player.speech.timer = 3000;
  }

  chatInput.addEventListener('keydown', (e)=>{
    if(e.key==='Enter'){
      const raw = (chatInput.value||'').trim();
      if(!raw) return;
      handleChatCommand(raw);
      chatInput.value='';
      closeChat();
    }
  });

  function handleChatCommand(raw){
    const cmd = raw.toUpperCase();
    speak(raw);

    if(cmd==='BLOCK-BLOCK'){
      grant('shield');
      toast('CHEAT: shield');
      return;
    }
    if(cmd==='ROW-ROW-BOW'){
      grant('bow');
      toast('CHEAT: bow');
      return;
    }
    if(cmd==='WIN-WIN-WIN'){
      player.hasWon=true;
      ending();
      return;
    }
    if(cmd==='END-END'){
      toast(L().secret);
      changeMap(MAP_SECRET, 10, 9);
      enemies=[];
      return;
    }
  }

  // ================= MULTIPLAYER (PROTOTYPE) =================
  // This is a lobby + local coop toggle. Real online requires backend/signaling.
  const mp = { enabled:false, mode:'', code:'' };

  function mpSet(enabled, mode, code){
    mp.enabled = enabled;
    mp.mode = mode || '';
    mp.code = code || '';
    all = loadAll();
    all.mp = { enabled: mp.enabled, mode: mp.mode, code: mp.code };
    saveAll(all);

    mpStatus.textContent = enabled ? `MP: ${mode} active` : 'MP: not active';
    mpCodeEl.textContent = `Code: ${code || '—'}`;
    toast(enabled ? L().mpOn : 'Multiplayer off');
  }

  function mpHost(){
    const code = randCode();
    mpSet(true, 'host', code);
  }
  function mpJoin(code){
    code = (code||'').trim().toUpperCase();
    if(code.length!==6){ toast('Invalid code'); return; }
    mpSet(true, 'join', code);
  }

  // ================= MENUS / SAVE =================
  const setMenu=(which)=>{
    UI.menu.classList.toggle('active', which==='main');
    UI.load.classList.toggle('active', which==='load');
    UI.settings.classList.toggle('active', which==='settings');
    UI.mp.classList.toggle('active', which==='mp');
  };

  function buildSlots(){
    const el=document.getElementById('slots');
    el.innerHTML='';
    const fmt=ts=> new Date(ts).toLocaleString();
    all=loadAll();

    all.slots.forEach((slot,idx)=>{
      const card=document.createElement('div');
      card.className='slot';
      const name=slot?.name||'';
      const dead=!!slot?.dead;

      card.innerHTML=`
        <h3>Slot ${idx+1} ${name? '— '+name:''} ${dead? '— ☠ DEAD':''}</h3>
        <div class="row">
          <input type="text" placeholder="Name this slot" value="${name}" class="slotname"/>
          <button class="btn ok" data-idx="${idx}" data-act="saveName">Save name</button>
        </div>
        <p class="note">${slot ? `HP ${slot.hp}/${slot.hpMax} · ${slot.map||'Overworld'} · ${slot.hasWon?'✨ Won':(dead?'☠ Dead':'In progress')} · Saved ${fmt(slot.ts)}` : 'Empty slot'}</p>
        <div class="row">
          <button class="btn primary" data-idx="${idx}" data-act="continue" ${slot && !dead ? '' : 'disabled'}>Continue</button>
          <button class="btn" data-idx="${idx}" data-act="newHere">New Here</button>
          <button class="btn danger" data-idx="${idx}" data-act="erase">Delete</button>
        </div>
      `;
      el.appendChild(card);
    });

    el.querySelectorAll('button').forEach(b=> b.addEventListener('click', evSlotBtn));
  }

  function evSlotBtn(e){
    const idx=+e.target.dataset.idx;
    const act=e.target.dataset.act;
    const card=e.target.closest('.slot');
    const nameInput=card.querySelector('.slotname');

    if(act==='saveName'){
      const name=(nameInput.value||'').trim();
      if(name.toLowerCase()==='pia'){ show(UI.egg,true); setTimeout(()=>show(UI.egg,false), 3000); }
      all=loadAll();
      all.slots[idx]=all.slots[idx]||{};
      all.slots[idx].name=name;
      saveAll(all);
      toast('Name saved');
      return;
    }

    if(act==='continue'){ loadFromSlot(idx); startGame(); return; }
    if(act==='newHere'){ newGame(idx); startGame(); return; }
    if(act==='erase'){ all=loadAll(); all.slots[idx]=null; saveAll(all); buildSlots(); toast('Slot cleared'); return; }
  }

  function newGame(slotIndex){
    player=makePlayer();
    player.slot=slotIndex;
    all=loadAll();
    player.name = all.slots[slotIndex]?.name||'';

    bosses = { boss1:null, boss2:null, boss3:null, finalPhase:1 };

    // start in castle with intro
    player.map = MAP_CASTLE;
    player.x = MAP_CASTLE.spawn.x; player.y = MAP_CASTLE.spawn.y;
    player.checkpoint = { mapName:'Royal Castle', x: player.x, y: player.y };

    inGame=true;
    HUD.root.style.display='flex';
    enemies=spawnForMap(player.map);

    // reset MP from saved state
    const mpSaved = loadAll().mp || {};
    mp.enabled = !!mpSaved.enabled;
    mp.mode = mpSaved.mode || '';
    mp.code = mpSaved.code || '';

    // place p2 near p1
    p2 = makePlayer2();
    p2.x = player.x + 12;
    p2.y = player.y;

    // intro story
    startIntro();
  }

  function loadFromSlot(idx){
    all=loadAll();
    const s=all.slots[idx];
    if(!s){ newGame(idx); return; }
    if(s.dead){ toast(L().deadSlot); newGame(idx); return; }

    player=makePlayer();
    player.slot=idx;

    Object.assign(player,{
      x:s.x??player.x, y:s.y??player.y,
      hp:s.hp??player.hp, hpMax:s.hpMax??player.hpMax,
      inv:s.inv||[],
      hotbar:s.hotbar||[null,null,null,null,null],
      potions:s.potions||0,
      hasWon:!!s.hasWon,
      name:s.name||'',
      checkpoint: s.checkpoint || player.checkpoint
    });

    const mapByName=(n)=>{
      if(n==='Royal Castle') return MAP_CASTLE;
      if(n==='Glimmer Caves') return MAP_CAVE;
      if(n==='Forest Ruins') return MAP_FOREST;
      if(n==='Frost Shrine') return MAP_FROST;
      if(n==='Shadow Nexus') return MAP_SHADOW;
      if(n==='Boss Lair') return MAP_BOSS;
      if(n==='Ash Wastes') return MAP_WASTES;
      if(n==='???') return MAP_SECRET;
      return MAP_OVERWORLD;
    };
    player.map=mapByName(s.map);

    bosses = s.bosses || { boss1:null, boss2:null, boss3:null, finalPhase:1 };

    enemies=spawnForMap(player.map);

    // restore MP
    const mpSaved = loadAll().mp || {};
    mp.enabled = !!mpSaved.enabled;
    mp.mode = mpSaved.mode || '';
    mp.code = mpSaved.code || '';

    p2 = makePlayer2();
    p2.x = player.x + 12;
    p2.y = player.y;
  }

  function saveToSlot(){
    if(!inGame) return;
    if(getDiff()==='hard'){ toast(L().hardNoSave); return; }

    const idx=player.slot||0;
    all=loadAll();
    const existing=all.slots[idx]||{};

    all.slots[idx]={
      x:player.x,y:player.y,
      hp:player.hp,hpMax:player.hpMax,
      inv:player.inv,
      hotbar:player.hotbar,
      potions:player.potions,
      map:player.map.name,
      hasWon:player.hasWon,
      name: existing.name||player.name||'',
      ts: Date.now(),
      dead:false,
      checkpoint: player.checkpoint,
      bosses: bosses
    };
    saveAll(all);
    toast(L().saved);
  }

  function startGame(){
    setMenu(null);
    show(HUD.root,true);
    inGame=true;
    paused=false;
    UI.pause.classList.remove('active');
    BTN.save.disabled = (getDiff()==='hard');
    requestAnimationFrame(update);
    render();
  }

  function returnToMenu(){
    inGame=false;
    paused=false;
    cutsceneActive=false;
    UI.pause.classList.remove('active');
    show(UI.cutscene,false);
    HUD.root.style.display='none';
    setMenu('main');
  }

  // ================= UI WIRING =================
  BTN.new.addEventListener('click', ()=>{ setMenu('load'); buildSlots(); toast(L().pickSlot); });
  BTN.load.addEventListener('click', ()=>{ setMenu('load'); buildSlots(); });
  BTN.settings.addEventListener('click', ()=> setMenu('settings'));
  BTN.mpOpen.addEventListener('click', ()=> setMenu('mp'));
  BTN.mpBack.addEventListener('click', ()=> setMenu('main'));

  BTN.mpHost.addEventListener('click', ()=>{
    mpHost();
    mpStatus.textContent = 'MP: host active';
    mpCodeEl.textContent = `Code: ${mp.code}`;
  });
  BTN.mpJoin.addEventListener('click', ()=>{
    mpJoin(joinCodeInput.value);
    mpStatus.textContent = 'MP: join active';
    mpCodeEl.textContent = `Code: ${mp.code}`;
  });

  BTN.exit.addEventListener('click', ()=>{
    window.close();
    setTimeout(()=>{ document.body.innerHTML='<div style="display:flex;align-items:center;justify-content:center;height:100vh;color:#ccd">Goodbye!</div>'; }, 100);
  });

  BTN.backFromLoad.addEventListener('click', ()=> setMenu('main'));
  BTN.backFromSettings.addEventListener('click', ()=> setMenu('main'));

  BTN.login.addEventListener('click', ()=>{
    all=loadAll();
    all.settings.nick=inputNick.value.trim();
    saveAll(all);
    toast(`Welcome${all.settings.nick? ', '+all.settings.nick:''}!`);
  });

  ddDifficulty.addEventListener('change', ()=>{
    all=loadAll();
    all.settings.difficulty=ddDifficulty.value;
    saveAll(all);
    toast('Difficulty: '+ddDifficulty.value.toUpperCase());
    BTN.save.disabled = (getDiff()==='hard');
  });

  ddLang.addEventListener('change', ()=>{
    all=loadAll();
    all.settings.lang=ddLang.value;
    saveAll(all);
    applyLang();
    toast('Language set.');
  });

  BTN.resume.addEventListener('click', ()=> togglePause());
  BTN.save.addEventListener('click', ()=> saveToSlot());
  BTN.mainMenu.addEventListener('click', ()=>{ saveToSlot(); returnToMenu(); });

  window.addEventListener('blur', ()=>{ if(inGame){ paused=true; UI.pause.classList.add('active'); BTN.save.disabled=(getDiff()==='hard'); }});

  // boot
  setMenu('main');
  show(HUD.root,false);
  toast('Ready! New Game → choose a slot.');
  requestAnimationFrame(update);
})();
</script>
</body>
</html>