<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>Echo of the Ember – Extended</title>
<style>
  :root{
    --fg:#e8f0ff;--bg:#0b0e14;--muted:#93a1b2;--accent:#00f6c7;--warn:#ff4d4d;--ok:#50c878;--panel:#0f1320;--edge:#1c2236;
  }
  html,body{height:100%;margin:0;background:radial-gradient(1200px 600px at 50% 0%, #121725 0%, #0b0e14 60%);color:var(--fg);font-family:Inter, ui-sans-serif, system-ui, Segoe UI, Roboto, Helvetica, Arial}
  *{box-sizing:border-box}
  .flex{display:flex}.col{flex-direction:column}.center{align-items:center;justify-content:center}
  .btn{background:linear-gradient(#151b2b,#0f1424);border:2px solid var(--edge);color:var(--fg);padding:.6rem 1rem;margin:.3rem 0;font-size:18px;cursor:pointer;border-radius:12px;transition:transform .06s ease, box-shadow .2s, border-color .2s}
  .btn:hover{transform:translateY(-1px);box-shadow:0 10px 24px rgba(0,0,0,.35);border-color:#2b3554}
  .btn:active{transform:translateY(1px)}
  .btn.primary{border-color:var(--accent)}
  .btn.danger{border-color:var(--warn)}
  .btn.ok{border-color:var(--ok)}
  .btn:disabled{opacity:.55;cursor:not-allowed}

  .menu{position:absolute;inset:0;display:none}
  .menu.active{display:flex}
  .panel{background:linear-gradient(180deg,var(--panel),#0c1020 40%, #0b0e14);border:2px solid var(--edge);border-radius:18px;box-shadow:0 40px 100px rgba(0,0,0,.55), inset 0 0 0 1px rgba(255,255,255,.03);padding:20px;min-width:520px;max-width:860px}
  h1,h2,h3{margin:.2rem 0}
  h1.title{font-size:48px;letter-spacing:.5px;line-height:1.1;text-shadow:0 2px 0 #000, 0 0 28px rgba(0,246,199,.35)}
  p.mono{font-family: ui-monospace, SFMono-Regular, Menlo, Consolas, monospace; color: var(--muted)}
  .row{display:flex;gap:12px;flex-wrap:wrap}
  .note{color:#aab1c4;font-size:12px;margin-top:6px}
  .grid{display:grid;grid-template-columns:repeat(2,minmax(200px,1fr));gap:12px}
  .slot{border:2px dashed var(--edge);border-radius:14px;padding:12px;background:rgba(255,255,255,.02)}
  .slot h3{margin:0 0 6px 0}
  input[type="text"], select{width:100%;background:#0b1022;border:2px solid var(--edge);color:var(--fg);padding:.55rem;border-radius:10px;font-size:16px}
  label{font-size:14px;color:#b9c1d8}

  .toast{position:fixed;left:50%;top:8%;transform:translateX(-50%);background:#0b1124;border:2px solid var(--edge);padding:.65rem 1rem;border-radius:12px;display:none;box-shadow:0 10px 24px rgba(0,0,0,.35);z-index:50}
  .toast.show{display:block}

  .hud{position:absolute;left:0;right:0;top:0;display:flex;justify-content:center;gap:8px;padding:8px 8px;font-family: ui-monospace, monospace;pointer-events:none;z-index:10}
  .hud .pill{background:rgba(10,14,28,.9);border:2px solid var(--edge);padding:6px 10px;border-radius:12px}

  .pauseOverlay{position:absolute;inset:0;background:rgba(5,8,16,.78);backdrop-filter:blur(2px);display:none;z-index:40}
  .pauseOverlay.active{display:flex}

  .cutscene{position:absolute;inset:auto 0 0 0;background:rgba(5,8,16,.92);padding:14px 16px;border-top:2px solid var(--edge);font-family: ui-monospace, monospace;z-index:30}
  .cutscene .name{color:var(--accent)}
  .egg{position:fixed;inset:auto 0 12% 0;display:none;justify-content:center;z-index:60}
  .egg .bubble{background:#0b1124;border:2px solid var(--accent);padding:10px 14px;border-radius:12px;box-shadow:0 10px 24px rgba(0,0,0,.35)}

  /* Chat overlay */
  .chatOverlay{position:absolute;inset:0;display:none;align-items:center;justify-content:center;z-index:70;background:rgba(5,8,16,.72);backdrop-filter:blur(2px)}
  .chatOverlay.active{display:flex}
  .chatBox{width:min(720px,92vw);background:#0b1124;border:2px solid var(--edge);border-radius:16px;box-shadow:0 30px 80px rgba(0,0,0,.65);padding:14px}
  .chatBox .head{display:flex;justify-content:space-between;align-items:center;margin-bottom:10px}
  .chatBox .head .title{font-family: ui-monospace, monospace;color:var(--muted)}
  .chatBox input{width:100%;padding:.7rem;border-radius:12px;border:2px solid var(--edge);background:#0b1022;color:var(--fg);font-size:16px}
  .chatHint{margin-top:8px;color:#9fb0c6;font-size:12px;font-family: ui-monospace, monospace}

  canvas{image-rendering: pixelated; image-rendering: crisp-edges; width: 960px; height: 540px; border:2px solid var(--edge); border-radius:14px; background:#000; box-shadow:0 30px 80px rgba(0,0,0,.6)}
  .viewport{position:relative;display:flex;gap:16px;align-items:flex-start;justify-content:center;margin:18px}
  @media (max-width: 1020px){ canvas{ width: 92vw; height: calc(92vw * 9 / 16);} }

  /* subtle CRT scanlines */
  .crt:before{content:"";position:absolute;inset:0;pointer-events:none;background:repeating-linear-gradient(to bottom, rgba(255,255,255,.03), rgba(255,255,255,.03) 1px, transparent 2px, transparent 4px);border-radius:14px}
</style>
</head>
<body>
<div class="viewport flex col center crt">
  <canvas id="game" width="320" height="180" aria-label="Retro canvas"></canvas>

  <div class="hud" id="hud" style="display:none">
    <div class="pill" id="hp">HP: --</div>
    <div class="pill" id="inv">Items: —</div>
    <div class="pill" id="where">Area: —</div>
    <div class="pill" id="diff">Diff: —</div>
  </div>

  <!-- MAIN MENU -->
  <section id="menu" class="menu active flex center">
    <div class="panel">
      <h1 class="title" id="tTitle">Echo of the Ember</h1>
      <p class="mono" id="tControls">
        Move: <b>WASD</b>/<b>Arrows</b> · Attack/Shoot: <b>SPACE</b> · Interact: <b>E</b> · Block: <b>ENTER</b> · Pause/Save: <b>T</b> · Chat: <b>R</b>
      </p>
      <div class="row">
        <button class="btn primary" id="btnNew">New Game</button>
        <button class="btn" id="btnLoad">Load Game</button>
        <button class="btn" id="btnSettings">Settings</button>
        <button class="btn danger" id="btnExit">Exit</button>
      </div>
      <p class="note" id="tNote">3 save slots. Hard = no saves + permadeath.</p>
    </div>
  </section>

  <!-- LOAD MENU -->
  <section id="load" class="menu flex center">
    <div class="panel">
      <h2 id="tLoadTitle">Load / Create Game</h2>
      <div id="slots" class="grid"></div>
      <div class="row" style="margin-top:8px">
        <button class="btn" id="backFromLoad">Back</button>
      </div>
    </div>
  </section>

  <!-- SETTINGS -->
  <section id="settings" class="menu flex center">
    <div class="panel">
      <h2 id="tSettings">Settings</h2>

      <div class="row">
        <div style="flex:1">
          <label id="tLang">Language</label>
          <select id="lang">
            <option value="de">Deutsch</option>
            <option value="en">English</option>
            <option value="fr">Français</option>
          </select>
          <p class="note" id="tLangNote">UI + messages.</p>
        </div>

        <div style="flex:1">
          <label id="tDiff">Difficulty</label>
          <select id="difficulty">
            <option value="easy">Easy</option>
            <option value="ok" selected>Ok</option>
            <option value="hard">Hard (no saves, permadeath)</option>
          </select>
        </div>

        <div style="flex:1">
          <label id="tNick">Nickname (local)</label>
          <div class="row">
            <input id="username" type="text" placeholder="Nickname" />
            <button id="btnLogin" class="btn ok" title="Save locally">Save</button>
          </div>
          <p class="note" id="tNickNote">Nickname is stored only in your browser.</p>
        </div>
      </div>

      <div class="row" style="margin-top:8px">
        <button class="btn" id="backFromSettings">Back</button>
      </div>
    </div>
  </section>

  <!-- PAUSE -->
  <section id="pause" class="pauseOverlay flex center col">
    <div class="panel" style="min-width:360px">
      <h2 id="tPaused">Paused</h2>
      <div class="row">
        <button id="btnResume" class="btn primary">Resume (T)</button>
        <button id="btnSave" class="btn ok">Save</button>
        <button id="btnMainMenu" class="btn">Main Menu</button>
      </div>
      <p class="note" id="tPauseNote">Hard mode disables saving.</p>
    </div>
  </section>

  <!-- CHAT -->
  <section id="chat" class="chatOverlay">
    <div class="chatBox">
      <div class="head">
        <div class="title" id="tChatTitle">Mini Chat (R)</div>
        <div class="title" id="tChatClose">Esc to close</div>
      </div>
      <input id="chatInput" type="text" placeholder="Type something and press Enter…" maxlength="40" />
      <div class="chatHint" id="tChatHint">Tip: There are secret codes…</div>
    </div>
  </section>

  <div id="cutscene" class="cutscene" style="display:none"></div>
  <div id="toast" class="toast"></div>
  <div id="egg" class="egg"><div class="bubble">Hi Pia, this game was designed for you</div></div>
</div>

<script>
(function(){
  // FAILSAFE
  window.addEventListener('error', (e)=>{
    const t = document.getElementById('toast');
    if(t){
      t.textContent = "JS Error: " + (e?.message || "unknown");
      t.classList.add('show');
    }
    console.error(e);
  });

  const canvas = document.getElementById('game');
  const ctx = canvas.getContext('2d');

  const HUD = {
    root: document.getElementById('hud'),
    hp: document.getElementById('hp'),
    inv: document.getElementById('inv'),
    where: document.getElementById('where'),
    diff: document.getElementById('diff')
  };
  const UI = {
    menu: document.getElementById('menu'),
    load: document.getElementById('load'),
    settings: document.getElementById('settings'),
    pause: document.getElementById('pause'),
    cutscene: document.getElementById('cutscene'),
    toast: document.getElementById('toast'),
    egg: document.getElementById('egg'),
    chat: document.getElementById('chat')
  };
  const BTN = {
    new: document.getElementById('btnNew'),
    load: document.getElementById('btnLoad'),
    settings: document.getElementById('btnSettings'),
    exit: document.getElementById('btnExit'),
    backFromLoad: document.getElementById('backFromLoad'),
    backFromSettings: document.getElementById('backFromSettings'),
    login: document.getElementById('btnLogin'),
    resume: document.getElementById('btnResume'),
    save: document.getElementById('btnSave'),
    mainMenu: document.getElementById('btnMainMenu')
  };
  const ddDifficulty = document.getElementById('difficulty');
  const ddLang = document.getElementById('lang');
  const inputNick = document.getElementById('username');
  const chatInput = document.getElementById('chatInput');

  const TILE = 16;
  const W = canvas.width, H = canvas.height;

  // helpers
  const clamp=(v,a,b)=>Math.max(a,Math.min(b,v));
  const now=()=>performance.now();
  const toast=(msg,ms=1800)=>{ UI.toast.textContent=msg; UI.toast.classList.add('show'); setTimeout(()=>UI.toast.classList.remove('show'),ms); };
  const show=(el,on)=>{ el.style.display = on ? (el.classList.contains('menu') ? 'flex' : 'block') : 'none'; };

  // persistence
  const STORE_KEY = 'echo-ember-saves-v4';
  const defaultSaves = () => ({ slots:[null,null,null], settings:{difficulty:'ok', lang:'de', nick:''} });
  function loadAll(){ try{ return JSON.parse(localStorage.getItem(STORE_KEY))||defaultSaves(); }catch(e){ return defaultSaves(); } }
  function saveAll(data){ localStorage.setItem(STORE_KEY, JSON.stringify(data)); }

  let all = loadAll();
  ddDifficulty.value = all.settings?.difficulty || 'ok';
  ddLang.value = all.settings?.lang || 'de';
  inputNick.value = all.settings?.nick || '';

  // i18n (small + practical)
  const I18N = {
    de:{
      note:"3 Save-Slots. Hard = keine Saves + Permadeath.",
      loadTitle:"Laden / Neues Spiel",
      settings:"Einstellungen",
      paused:"Pause",
      pauseNote:"Hard deaktiviert Speichern.",
      lang:"Sprache",
      langNote:"UI + Meldungen.",
      diff:"Schwierigkeit",
      nick:"Nickname (lokal)",
      nickNote:"Wird nur im Browser gespeichert.",
      chatTitle:"Mini-Chat (R)",
      chatClose:"Esc zum Schließen",
      chatHint:"Tipp: Es gibt geheime Codes…",
      pickSlot:"Wähle einen Slot.",
      saved:"Gespeichert",
      hardNoSave:"HARD: Speichern deaktiviert.",
      deadSlot:"Slot ist DEAD. Starte 'New Here'.",
      need:"Du brauchst: ",
      locked:"Verschlossen. Schlüssel fehlt: ",
      portal:"Portal → ",
      pressE:"Drücke E",
      chest:"Drücke E um Truhe zu öffnen",
      talk:"Drücke E um zu reden",
      blocked:"Geblockt!",
      blockedReduced:"Geblockt (weniger Schaden)!",
      respawn:"Respawn!",
      permadeath:"HARD: Permadeath. Slot als DEAD markiert.",
      win:"Sieg!",
      secret:"Geheimes Level…",
    },
    en:{
      note:"3 save slots. Hard = no saves + permadeath.",
      loadTitle:"Load / Create Game",
      settings:"Settings",
      paused:"Paused",
      pauseNote:"Hard disables saving.",
      lang:"Language",
      langNote:"UI + messages.",
      diff:"Difficulty",
      nick:"Nickname (local)",
      nickNote:"Stored only in your browser.",
      chatTitle:"Mini Chat (R)",
      chatClose:"Esc to close",
      chatHint:"Tip: There are secret codes…",
      pickSlot:"Pick a slot.",
      saved:"Saved",
      hardNoSave:"HARD: Saving disabled.",
      deadSlot:"This slot is DEAD. Start New Here.",
      need:"You need: ",
      locked:"Locked. Missing key: ",
      portal:"Portal → ",
      pressE:"Press E",
      chest:"Press E to open chest",
      talk:"Press E to talk",
      blocked:"Blocked!",
      blockedReduced:"Blocked (reduced)!",
      respawn:"Respawned!",
      permadeath:"HARD: Permadeath. Slot marked DEAD.",
      win:"Victory!",
      secret:"Secret level…",
    },
    fr:{
      note:"3 emplacements. Difficile = pas de sauvegarde + mort définitive.",
      loadTitle:"Charger / Nouveau",
      settings:"Paramètres",
      paused:"Pause",
      pauseNote:"Difficile désactive la sauvegarde.",
      lang:"Langue",
      langNote:"Interface + messages.",
      diff:"Difficulté",
      nick:"Pseudo (local)",
      nickNote:"Stocké uniquement dans le navigateur.",
      chatTitle:"Mini Chat (R)",
      chatClose:"Esc pour fermer",
      chatHint:"Astuce : il y a des codes secrets…",
      pickSlot:"Choisis un slot.",
      saved:"Sauvegardé",
      hardNoSave:"DIFFICILE : sauvegarde désactivée.",
      deadSlot:"Ce slot est MORT. Lance 'New Here'.",
      need:"Il te faut : ",
      locked:"Fermé. Clé manquante : ",
      portal:"Portail → ",
      pressE:"Appuie sur E",
      chest:"Appuie sur E pour ouvrir",
      talk:"Appuie sur E pour parler",
      blocked:"Bloqué !",
      blockedReduced:"Bloqué (réduit) !",
      respawn:"Réapparition !",
      permadeath:"DIFFICILE : mort définitive. Slot marqué MORT.",
      win:"Victoire !",
      secret:"Niveau secret…",
    }
  };
  const L = ()=> I18N[getLang()] || I18N.de;
  function getLang(){ return (loadAll().settings?.lang) || 'de'; }
  function getDiff(){ return (loadAll().settings?.difficulty) || 'ok'; }

  function applyLang(){
    const t = L();
    document.getElementById('tNote').textContent = t.note;
    document.getElementById('tLoadTitle').textContent = t.loadTitle;
    document.getElementById('tSettings').textContent = t.settings;
    document.getElementById('tPaused').textContent = t.paused;
    document.getElementById('tPauseNote').textContent = t.pauseNote;
    document.getElementById('tLang').textContent = t.lang;
    document.getElementById('tLangNote').textContent = t.langNote;
    document.getElementById('tDiff').textContent = t.diff;
    document.getElementById('tNick').textContent = t.nick;
    document.getElementById('tNickNote').textContent = t.nickNote;
    document.getElementById('tChatTitle').textContent = t.chatTitle;
    document.getElementById('tChatClose').textContent = t.chatClose;
    document.getElementById('tChatHint').textContent = t.chatHint;
    chatInput.placeholder = (getLang()==='de') ? "Tippe etwas und drücke Enter…" : (getLang()==='fr' ? "Tape et appuie sur Entrée…" : "Type and press Enter…");
  }
  applyLang();

  // input
  const keys=new Map();
  let chatOpen=false;
  function setKey(e,down){
    const k=e.key;
    keys.set(k.toLowerCase(),down);
    if(['ArrowUp','ArrowDown','ArrowLeft','ArrowRight'].includes(k)) keys.set(k,down);

    // pause toggle
    if((k==='t'||k==='T') && inGame && !chatOpen){
      togglePause();
      e.preventDefault();
    }

    // chat toggle
    if((k==='r'||k==='R') && inGame){
      if(down) toggleChat();
      e.preventDefault();
    }

    // esc close chat
    if(k==='Escape' && chatOpen && down){
      closeChat();
      e.preventDefault();
    }
  }
  window.addEventListener('keydown',e=>setKey(e,true));
  window.addEventListener('keyup',e=>setKey(e,false));

  // ================= MAPS =================
  // tile ids:
  // 0 floor
  // 1 wall
  // 2 rock
  // 4 stump
  // 5 decor
  // 6 decor
  // 7 portal tile
  // 8 gate marker
  // 10 ice
  // 11 dark floor
  const COLORS = {0:'#1c8c2d',1:'#3e4356',2:'#254070',4:'#865528',5:'#a7cc77',6:'#d7d7d7',7:'#6b76c8',8:'#9b0e0e',10:'#7aa6ff',11:'#0a0a10'};
  function makeMap(name, tiles, encounters){ return {name, w:20, h:12, tiles, encounters:encounters||[], npcs:[], chests:[], doors:[], bossDef:null}; }
  const isBlocked=id=> id===1 || id===2;
  const tileAt=(map,px,py)=>{ const tx=clamp(Math.floor(px/TILE),0,map.w-1), ty=clamp(Math.floor(py/TILE),0,map.h-1); return { id: map.tiles[ty*map.w+tx], x:tx, y:ty }; };

  // === maps (overworld + 3 worlds + shadow + boss + secret) ===
  const MAP_OVERWORLD = makeMap('Overworld',[
    1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,
    1,0,0,0,0,0,0,0,0,6,0,0,0,0,0,0,0,0,4,1,
    1,0,0,0,1,1,1,0,0,0,0,0,1,1,1,0,5,0,0,1,
    1,0,0,0,1,2,1,0,0,0,0,0,1,2,1,0,0,0,0,1,
    1,0,7,0,1,0,1,0,1,1,1,0,1,0,1,0,0,0,0,1,
    1,0,0,0,0,0,0,0,1,2,1,0,0,0,0,0,0,0,0,1,
    1,0,0,0,1,1,1,0,1,0,1,0,1,1,1,0,0,0,0,1,
    1,0,0,0,1,0,1,0,1,0,1,0,1,0,1,0,0,0,0,1,
    1,0,0,0,1,0,1,0,1,0,1,0,1,0,1,0,0,0,0,1,
    1,0,0,0,0,0,0,0,1,0,1,0,0,0,0,0,0,0,0,1,
    1,4,0,0,1,0,1,0,1,0,1,0,1,0,1,0,0,0,8,1,
    1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1
  ]);

  const MAP_CAVE = makeMap('Glimmer Caves',[
    1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,
    1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,7,1,
    1,0,1,1,1,0,1,1,1,0,1,1,1,0,1,1,1,0,0,1,
    1,0,1,5,1,0,1,6,1,0,1,5,1,0,1,6,1,0,0,1,
    1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,0,1,
    1,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,
    1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,0,1,
    1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,0,1,
    1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,
    1,0,0,0,1,1,1,0,1,0,1,0,1,1,1,0,0,0,0,1,
    1,7,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,4,1,
    1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1
  ]);

  const MAP_FOREST = makeMap('Forest Ruins',[
    1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,
    1,0,0,0,0,0,0,0,0,4,0,0,0,0,0,0,0,0,7,1,
    1,0,1,1,1,0,1,1,1,0,1,1,1,0,1,1,1,0,0,1,
    1,0,1,0,1,0,1,5,1,0,1,0,1,0,1,6,1,0,0,1,
    1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,0,1,
    1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,
    1,0,1,0,1,0,1,0,1,1,1,0,1,0,1,0,1,0,0,1,
    1,0,1,0,1,0,1,0,0,0,0,0,1,0,1,0,1,0,0,1,
    1,0,0,0,0,0,0,0,1,1,1,0,0,0,0,0,0,0,0,1,
    1,0,0,0,1,1,1,0,1,0,1,0,1,1,1,0,0,0,0,1,
    1,7,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,7,1,
    1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1
  ]);

  const MAP_FROST = makeMap('Frost Shrine',[
    1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,
    1,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,7,1,
    1,10,1,1,1,10,1,1,1,10,1,1,1,10,1,1,1,10,10,1,
    1,10,1,6,1,10,1,0,1,10,1,6,1,10,1,0,1,10,10,1,
    1,10,1,0,1,10,1,0,1,10,1,0,1,10,1,0,1,10,10,1,
    1,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,1,
    1,10,1,0,1,10,1,0,1,10,1,0,1,10,1,0,1,10,10,1,
    1,10,1,0,1,10,1,5,1,10,1,0,1,10,1,6,1,10,10,1,
    1,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,1,
    1,10,10,10,1,1,1,10,1,10,1,10,1,1,1,10,10,10,10,1,
    1,7,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,7,1,
    1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1
  ]);

  const MAP_SHADOW = makeMap('Shadow Nexus',[
    1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,
    1,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,7,1,
    1,11,1,1,1,11,1,1,1,11,1,1,1,11,1,1,1,11,11,1,
    1,11,1,0,1,11,1,0,1,11,1,0,1,11,1,0,1,11,11,1,
    1,11,1,0,1,11,1,0,1,11,1,0,1,11,1,0,1,11,11,1,
    1,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,1,
    1,11,1,0,1,11,1,0,1,11,1,0,1,11,1,0,1,11,11,1,
    1,11,1,0,1,11,1,0,1,11,1,0,1,11,1,0,1,11,11,1,
    1,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,1,
    1,11,11,11,1,1,1,11,1,11,1,11,1,1,1,11,11,11,11,1,
    1,7,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,7,1,
    1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1
  ]);

  const MAP_BOSS = makeMap('Boss Lair',[
    1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,
    1,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,1,
    1,11,1,1,1,11,1,1,1,11,1,1,1,11,1,1,1,11,11,1,
    1,11,1,0,1,11,1,0,1,11,1,0,1,11,1,0,1,11,11,1,
    1,11,1,0,1,11,1,0,1,11,1,0,1,11,1,0,1,11,11,1,
    1,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,1,
    1,11,1,0,1,11,1,0,1,11,1,0,1,11,1,0,1,11,11,1,
    1,11,1,0,1,11,1,0,1,11,1,0,1,11,1,0,1,11,11,1,
    1,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,1,
    1,11,11,11,1,1,1,11,1,11,1,11,1,1,1,11,11,11,11,1,
    1,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,1,
    1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1
  ]);

  const MAP_SECRET = makeMap('???',[
    1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,
    1,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,1,
    1,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,1,
    1,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,1,
    1,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,1,
    1,11,11,11,11,11,11,11,11,11,7,11,11,11,11,11,11,11,11,1,
    1,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,1,
    1,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,1,
    1,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,1,
    1,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,1,
    1,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,1,
    1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1
  ]);

  function addDoor(a,x,y,b,tx,ty,opts={}){ a.doors.push({x,y,to:b,tx,ty, ...opts}); }

  // Portal logic: YOU MUST STAND ON TILE and press E to use
  addDoor(MAP_OVERWORLD,2,4,MAP_CAVE,2,10,{label:'Caves'});
  addDoor(MAP_CAVE,18,1,MAP_OVERWORLD,18,9,{label:'Overworld'});

  addDoor(MAP_CAVE,1,1,MAP_FOREST,2,10,{label:'Forest', requireKey:'key1'});
  addDoor(MAP_FOREST,18,1,MAP_CAVE,2,2,{label:'Caves'});

  addDoor(MAP_FOREST,18,10,MAP_FROST,2,10,{label:'Frost', requireKey:'key2'});
  addDoor(MAP_FROST,1,10,MAP_FOREST,17,2,{label:'Forest'});

  addDoor(MAP_FROST,18,1,MAP_SHADOW,2,10,{label:'Shadow', requireKey:'key3'});
  addDoor(MAP_SHADOW,1,10,MAP_FROST,17,2,{label:'Frost'});

  addDoor(MAP_SHADOW,18,10,MAP_BOSS,2,9,{label:'Boss', requireItems:['bow','shield']});
  addDoor(MAP_BOSS,1,9,MAP_SHADOW,17,2,{label:'Shadow'});

  // Secret: only via code, but portal (tile 7) in center triggers secret cutscene
  addDoor(MAP_SECRET,10,5,MAP_SECRET,10,5,{label:'Secret Portal', secretPortal:true});

  // CONTENT: chests & NPCs & encounters
  MAP_OVERWORLD.encounters=[{x:6,y:5,type:'slime'},{x:14,y:6,type:'slime'},{x:3,y:8,type:'slime'}];
  MAP_OVERWORLD.chests.push({x:16,y:2,item:'key1',opened:false});
  MAP_OVERWORLD.npcs.push({x:9,y:1,text:"Find keys. In the caves: sword and bow."});

  MAP_CAVE.encounters=[{x:5,y:5,type:'bat'},{x:15,y:5,type:'bat'}];
  MAP_CAVE.chests.push({x:11,y:3,item:'sword',opened:false});
  MAP_CAVE.chests.push({x:16,y:9,item:'bow',opened:false});
  MAP_CAVE.chests.push({x:3,y:3,item:'potion',opened:false});
  MAP_CAVE.npcs.push({x:7,y:3,text:"With the bow, sword enemies will appear."});

  // BOSSES live on worlds: Forest boss + Frost boss + Final boss map
  MAP_FOREST.encounters=[{x:6,y:5,type:'slime'},{x:14,y:7,type:'slime'},{x:10,y:5,type:'bandit'}]; // bandit only after bow
  MAP_FOREST.chests.push({x:7,y:3,item:'potion',opened:false});
  MAP_FOREST.npcs.push({x:7,y:10,text:"A corrupted guardian hides deeper in these ruins…"});
  MAP_FOREST.bossDef = { id:'boss1', name:'Root Warden', x: 13*TILE, y: 6*TILE };

  MAP_FROST.encounters=[{x:6,y:5,type:'bat'},{x:14,y:5,type:'bandit'}];
  MAP_FROST.chests.push({x:7,y:7,item:'shield',opened:false});
  MAP_FROST.chests.push({x:15,y:3,item:'potion',opened:false});
  MAP_FROST.bossDef = { id:'boss2', name:'Ice Sentinel', x: 13*TILE, y: 6*TILE };

  MAP_SHADOW.encounters=[{x:10,y:5,type:'bandit'},{x:14,y:7,type:'emberling'}];
  MAP_SHADOW.npcs.push({x:7,y:3,text:"Final door: bow + shield. ENTER blocks. SPACE shoots."});

  MAP_BOSS.bossDef = { id:'boss3', name:'Ash Tyrant', x: 12*TILE, y: 5*TILE };

  // ================= PLAYER / STATE =================
  function makePlayer(){
    return {
      x:2*TILE,y:2*TILE,w:12,h:12,
      dir:1,
      hp:10,hpMax:10,
      inv:[],
      map:MAP_OVERWORLD,
      slot:0,
      name:'',
      hasWon:false,
      iFrames:0,
      blocking:false,
      blockTimer:0,
      lastArrow:0,
      checkpoint:{ mapName:'Overworld', x:2*TILE, y:2*TILE },
      speech:{ text:'', timer:0 }
    };
  }
  let player = makePlayer();

  const DIFF = {
    easy:{ enemyHp:3, enemyDmg:1, bossHp1:18, bossHp2:22, bossHp3:34, bossDmg:2, fire:2, respawn:true },
    ok:  { enemyHp:5, enemyDmg:2, bossHp1:24, bossHp2:28, bossHp3:44, bossDmg:3, fire:3, respawn:true },
    hard:{ enemyHp:7, enemyDmg:3, bossHp1:30, bossHp2:34, bossHp3:56, bossDmg:4, fire:4, respawn:false }
  };
  const D = ()=> DIFF[getDiff()] || DIFF.ok;

  const has=item=> player.inv.includes(item);
  function grant(item){
    if(!has(item)){
      player.inv.push(item);
      toast(`+ ${item}`);
      if(item==='bow' || item==='shield') setCheckpoint();
    }
  }
  function setCheckpoint(){
    player.checkpoint = { mapName: player.map.name, x: player.x, y: player.y };
  }

  // ================= ENTITIES =================
  const overlap=(a,b)=> !(a.x+a.w<b.x || b.x+b.w<a.x || a.y+a.h<b.y || b.y+b.h<a.y);
  function moveEntity(e,dx,dy){
    const map=e.map||player.map;
    const nx=e.x+dx, ny=e.y+dy;
    const corners=[ tileAt(map,nx,ny), tileAt(map,nx+e.w,ny), tileAt(map,nx,ny+e.h), tileAt(map,nx+e.w,ny+e.h) ];
    if(corners.some(c=>isBlocked(c.id))) return;
    e.x=nx; e.y=ny;
  }

  function makeEnemy(type,x,y){
    const d=D();
    const e={x,y,w:12,h:12,type,hp:d.enemyHp,alive:true,dmg:d.enemyDmg,lastHit:0};
    if(type==='bat'){ e.w=10;e.h=10; }
    if(type==='emberling'){ e.hp+=2; e.dmg+=1; }
    if(type==='bandit'){ e.hp+=3; e.dmg+=2; }
    return e;
  }
  function spawnForMap(map){
    return map.encounters
      .filter(en => en.type!=='bandit' || has('bow')) // bandits only after bow
      .map(en=> makeEnemy(en.type, en.x*TILE+2, en.y*TILE+2));
  }
  let enemies = spawnForMap(MAP_OVERWORLD);

  // projectiles
  const arrows=[];
  const fireballs=[];

  function shootArrow(){
    if(!has('bow')) return;
    const t=now();
    if(t-player.lastArrow<280) return;
    player.lastArrow=t;
    const speed=140;
    arrows.push({
      x: player.x + (player.dir===1 ? player.w+1 : -3),
      y: player.y + 5,
      w:3,h:2,
      vx: (player.dir===1? speed : -speed),
      vy:0,
      life: 1200
    });
  }

  // Boss system: 3 bosses, final has 2 phases (phase2 spawns all 3 together)
  let bosses = {
    boss1: null,
    boss2: null,
    boss3: null,   // final
    finalPhase: 1  // 1 or 2
  };
  const bossAlive = (b)=> b && b.alive;

  function spawnBoss(id, map){
    const d=D();
    const def = map.bossDef;
    if(!def || def.id!==id) return null;

    let hp = d.bossHp3, dmg = d.bossDmg, kind='final';
    if(id==='boss1'){ hp=d.bossHp1; dmg=d.bossDmg-1; kind='root'; }
    if(id==='boss2'){ hp=d.bossHp2; dmg=d.bossDmg; kind='ice'; }
    if(id==='boss3'){ hp=d.bossHp3; dmg=d.bossDmg+1; kind='ash'; }

    return {
      id, kind,
      x:def.x, y:def.y, w:(id==='boss3'?24:18), h:(id==='boss3'?20:16),
      hp, hpMax:hp, dmg,
      alive:true, lastHit:0, lastFire:0, lastDash:0
    };
  }

  function ensureBossForMap(map){
    if(!map.bossDef) return;

    const id = map.bossDef.id;
    if(!bosses[id]){
      bosses[id] = spawnBoss(id, map);
    } else {
      // keep boss inside map; do not respawn dead bosses
      // but if player enters again, keep position stable
    }
  }

  function bossFire(b){
    const t=now();
    const cd = (b.id==='boss3') ? (b.hp < b.hpMax*0.55 ? 650 : 950) : 1200;
    if(t-b.lastFire<cd) return;
    b.lastFire=t;

    const dx=(player.x-b.x), dy=(player.y-b.y);
    const len=Math.max(1, Math.hypot(dx,dy));
    const speed = (b.id==='boss3') ? 105 : 85;

    fireballs.push({x:b.x+b.w/2,y:b.y+b.h/2,w:4,h:4,vx:(dx/len)*speed,vy:(dy/len)*speed,life:2200, from:b.id});
  }

  function bossAI(b, dt){
    if(!b.alive) return;
    const t=now();
    const s = (b.id==='boss3' ? 30 : 34) * dt;

    // basic chase
    moveEntity(b, Math.sign(player.x-b.x)*s, Math.sign(player.y-b.y)*s);

    // contact dmg
    if(overlap(b,player) && (t-b.lastHit)>520){
      b.lastHit=t;
      damagePlayer(b.dmg, 'hit');
    }

    // patterns
    if(b.id==='boss1'){ // root warden: occasional dash
      if(t-b.lastDash>1400){
        b.lastDash=t;
        moveEntity(b, Math.sign(player.x-b.x)*18, Math.sign(player.y-b.y)*18);
      }
    }
    if(b.id==='boss2'){ // ice sentinel: more frequent fireballs
      if(t-b.lastFire>900) bossFire(b);
    }
    if(b.id==='boss3'){ // ash tyrant: fire spam
      bossFire(b);
      if(bosses.finalPhase===2 && t-b.lastDash>1200){
        b.lastDash=t;
        moveEntity(b, Math.sign(player.x-b.x)*22, Math.sign(player.y-b.y)*22);
      }
    }
  }

  // ================= DRAW =================
  const rect=(x,y,w,h,c)=>{ ctx.fillStyle=c; ctx.fillRect(x,y,w,h); };

  function drawMap(map){
    for(let y=0;y<map.h;y++){
      for(let x=0;x<map.w;x++){
        const id=map.tiles[y*map.w+x];
        let c=COLORS[id]||'#222';

        // area tints (simple)
        if(id===0 && map===MAP_OVERWORLD) c = (((x+y)&1)? '#187528':'#1f9a34');
        if(id===0 && map===MAP_CAVE) c = (((x+y)&1)? '#1b2030':'#1f2538');
        if(id===0 && map===MAP_FOREST) c = (((x+y)&1)? '#245a2d':'#2d7336');
        if(id===0 && map===MAP_FROST) c = (((x+y)&1)? '#1b2a3f':'#203252');
        if(id===0 && (map===MAP_SHADOW||map===MAP_BOSS||map===MAP_SECRET)) c = (((x+y)&1)? '#07070c':'#0c0c14');
        if(id===10) c = (((x+y)&1)? '#6f9cff':'#86b0ff');
        if(id===11) c = (((x+y)&1)? '#06060a':'#0a0a10');

        rect(x*TILE,y*TILE,TILE,TILE,c);

        // decor markers
        if(id===5){ rect(x*TILE+4,y*TILE+4,8,8,'#c93'); rect(x*TILE+4,y*TILE+6,8,4,'#642'); }
        if(id===6){ rect(x*TILE+2,y*TILE+6,12,4,'#bbb'); }
        if(id===4){ rect(x*TILE+4,y*TILE+4,8,8,'#543'); }
        if(id===7){ rect(x*TILE+3,y*TILE+3,10,10,'#6b76c8'); rect(x*TILE+5,y*TILE+5,6,6,'#0b0e14'); }
        if(id===8){ rect(x*TILE+2,y*TILE+2,12,12,'#410'); rect(x*TILE+5,y*TILE+5,6,6,'#900'); }
      }
    }
  }

  function drawPlayer(){
    rect(player.x-1,player.y-1,player.w+2,player.h+2,'#000');
    rect(player.x,player.y,player.w,player.h, player.blocking ? '#cfe6ff':'#eaeaea');

    // face
    if(player.dir===-1) rect(player.x+2,player.y+4,3,3,'#111'); else rect(player.x+7,player.y+4,3,3,'#111');

    // sword
    if(has('sword')){
      if(player.dir===1) rect(player.x+player.w, player.y+3, 6,2, '#ddd');
      else rect(player.x-6, player.y+3, 6,2, '#ddd');
    }
    // bow
    if(has('bow')){
      const bx = (player.dir===1? player.x+player.w-1 : player.x-2);
      rect(bx, player.y+2, 2, 9, '#b5853a');
      rect(bx+(player.dir===1? 1:-1), player.y+2, 1, 9, '#e8f0ff');
    }
    // shield
    if(has('shield') && player.blocking){
      const sx = (player.dir===1? player.x+player.w : player.x-5);
      rect(sx, player.y+3, 5, 7, '#6b76c8');
      rect(sx+1, player.y+4, 3, 5, '#0b0e14');
    }

    // speech bubble (simple)
    if(player.speech.timer>0 && player.speech.text){
      const text = player.speech.text.slice(0,40);
      const bw = Math.min(180, 10 + text.length*6);
      const bx = clamp(player.x - bw/2 + player.w/2, 2, W-bw-2);
      const by = clamp(player.y - 18, 2, H-18);
      rect(bx-1,by-1,bw+2,14+2,'#000');
      rect(bx,by,bw,14,'#0b1124');
      ctx.fillStyle = '#e8f0ff';
      ctx.font = '10px ui-monospace, monospace';
      ctx.fillText(text, bx+6, by+10);
    }
  }

  function drawEnemies(){
    enemies.forEach(e=>{
      if(!e.alive) return;
      let color='#39f';
      if(e.type==='bat') color='#bbb';
      if(e.type==='emberling') color='#f64';
      if(e.type==='bandit') color='#d6c08a';
      rect(e.x-1,e.y-1,e.w+2,e.h+2,'#000');
      rect(e.x,e.y,e.w,e.h,color);
      if(e.type==='bandit') rect(e.x+e.w,e.y+4,6,2,'#ddd');
    });
  }

  function drawProjectiles(){
    arrows.forEach(a=>{ rect(a.x-1,a.y-1,a.w+2,a.h+2,'#000'); rect(a.x,a.y,a.w,a.h,'#e8f0ff'); });
    fireballs.forEach(f=>{ rect(f.x-1,f.y-1,f.w+2,f.h+2,'#000'); rect(f.x,f.y,f.w,f.h,'#ff6a3a'); rect(f.x+1,f.y+1,2,2,'#ffd27a'); });
  }

  function drawBoss(b){
    if(!b || !b.alive) return;

    // big-ish outline
    rect(b.x-2,b.y-2,b.w+4,b.h+4,'#000');

    let body='#3a0b0f', inner='#6a1119', eye='#ffd27a';
    if(b.id==='boss1'){ body='#243a1b'; inner='#2d7336'; eye='#e8f0ff'; }
    if(b.id==='boss2'){ body='#142642'; inner='#203252'; eye='#7aa6ff'; }

    rect(b.x,b.y,b.w,b.h,body);
    rect(b.x+2,b.y+2,b.w-4,b.h-4,inner);

    rect(b.x+5,b.y+6,4,3,eye);
    rect(b.x+b.w-9,b.y+6,4,3,eye);

    // hp bar
    const bw = b.w;
    const hpw = Math.max(0, Math.floor((b.hp/b.hpMax)*bw));
    rect(b.x, b.y-6, bw, 3, '#0b0e14');
    rect(b.x, b.y-6, hpw, 3, '#00f6c7');

    if(b.id==='boss3'){
      // mouth hint
      rect(b.x+b.w/2-5,b.y+b.h-6,10,3,'#0b0e14');
      rect(b.x+b.w/2-4,b.y+b.h-5,8,1,'#ff6a3a');
    }
  }

  // ================= COMBAT =================
  function damagePlayer(n, source='hit'){
    if(player.iFrames>0) return;

    // block
    if(player.blocking && has('shield')){
      n *= (source==='fire') ? 0.15 : 0.35;
      if(n < 0.2){ toast(L().blocked); return; }
      toast(L().blockedReduced);
    }

    player.hp -= n;
    player.iFrames = 360;
    if(player.hp<=0){ player.hp=0; onDeath(); }
  }

  function meleeHitbox(){
    return { x: player.x + (player.dir===1? player.w:-8), y: player.y+2, w:8, h:8 };
  }

  function attackEntityMelee(target){
    if(!has('sword')) return;
    const range=meleeHitbox();
    if(overlap(range,target)){
      target.hp--;
      if(target.hp<=0) target.alive=false;
      target.lastHit=now();
    }
  }

  function handleArrowHits(){
    for(const a of arrows){
      // enemies
      enemies.forEach(e=>{
        if(e.alive && overlap(a,e)){
          e.hp -= 1;
          if(e.hp<=0) e.alive=false;
          a.life=0;
        }
      });

      // bosses:
      // rule: boss3 (final) must be hurt by bow (arrow). boss1 & boss2 can be hurt by sword OR arrow.
      const bs = [bosses.boss1, bosses.boss2, bosses.boss3];
      for(const b of bs){
        if(b && b.alive && overlap(a,b)){
          b.hp -= 1;
          a.life=0;
        }
      }
    }
  }

  // ================= GAME LOOP =================
  let last=0, dt=0, paused=false, inGame=false, transitioning=false;

  function togglePause(){
    if(chatOpen) return;
    paused=!paused;
    UI.pause.classList.toggle('active', paused);
    BTN.save.disabled = (getDiff()==='hard');
  }

  function render(){
    ctx.imageSmoothingEnabled=false;
    ctx.clearRect(0,0,W,H);

    drawMap(player.map);
    drawEnemies();

    // bosses in this map
    if(player.map.bossDef){
      const id = player.map.bossDef.id;
      drawBoss(bosses[id]);
    }
    // phase 2 draws all bosses (only in boss lair)
    if(player.map===MAP_BOSS && bosses.finalPhase===2){
      drawBoss(bosses.boss1);
      drawBoss(bosses.boss2);
      drawBoss(bosses.boss3);
    }

    drawProjectiles();
    drawPlayer();

    // HUD text
    HUD.hp.textContent = `HP: ${Math.max(0,player.hp).toFixed(0)}/${player.hpMax}`;
    HUD.inv.textContent = `Items: ${player.inv.join(', ')||'None'}`;
    let bossInfo = '';
    if(player.map===MAP_BOSS && bosses.boss3){
      bossInfo = ` · Final P${bosses.finalPhase}`;
    }
    HUD.where.textContent = `Area: ${player.map.name}${bossInfo}`;
    HUD.diff.textContent = `Diff: ${getDiff().toUpperCase()}`;
  }

  let sayTimer=0;
  function say(text, ms=1400){
    UI.cutscene.innerHTML = `<span class="name">✦</span> ${text}`;
    show(UI.cutscene,true);
    clearTimeout(sayTimer);
    sayTimer=setTimeout(()=>show(UI.cutscene,false), ms);
  }

  function update(t){
    dt=(t-last)/1000; last=t;

    if(!inGame || paused || chatOpen){
      requestAnimationFrame(update);
      return;
    }

    player.iFrames = Math.max(0, player.iFrames - dt*1000);
    player.blockTimer = Math.max(0, player.blockTimer - dt*1000);
    if(player.blockTimer<=0) player.blocking=false;

    if(player.speech.timer>0){
      player.speech.timer -= dt*1000;
      if(player.speech.timer<=0){ player.speech.timer=0; player.speech.text=''; }
    }

    // block enter
    if((keys.get('enter') || keys.get('Enter')) && has('shield')){
      player.blocking=true;
      player.blockTimer=140;
    }

    // movement
    const sp=75;
    let dx=0,dy=0;
    if(keys.get('a')||keys.get('arrowleft')){ dx-=sp*dt; player.dir=-1; }
    if(keys.get('d')||keys.get('arrowright')){ dx+=sp*dt; player.dir= 1; }
    if(keys.get('w')||keys.get('arrowup')){ dy-=sp*dt; }
    if(keys.get('s')||keys.get('arrowdown')){ dy+=sp*dt; }
    if(dx!==0) moveEntity(player,dx,0);
    if(dy!==0) moveEntity(player,0,dy);

    // frost chip damage
    const ct = tileAt(player.map, player.x+player.w/2, player.y+player.h/2);
    if(player.map===MAP_FROST && ct.id===10){
      damagePlayer(0.9*dt,'hit');
      if(dx!==0) moveEntity(player, dx*0.35, 0);
      if(dy!==0) moveEntity(player, 0, dy*0.35);
    }

    // attack
    if(keys.get(' ')){
      enemies.forEach(e=> e.alive && attackEntityMelee(e));
      // bosses: sword works on boss1/boss2, NOT on boss3 final
      if(player.map.bossDef){
        const id = player.map.bossDef.id;
        const b = bosses[id];
        if(b && b.alive && id!=='boss3') attackEntityMelee(b);
      }
      // in phase2: sword can hit boss1+boss2 but not final
      if(player.map===MAP_BOSS && bosses.finalPhase===2){
        if(bossAlive(bosses.boss1)) attackEntityMelee(bosses.boss1);
        if(bossAlive(bosses.boss2)) attackEntityMelee(bosses.boss2);
      }
      // bow shooting always
      shootArrow();
    }

    // enemies chase
    enemies.forEach(e=>{
      if(!e.alive) return;
      const s = (e.type==='bandit'? 44:38)*dt;
      moveEntity(e, Math.sign(player.x-e.x)*s, Math.sign(player.y-e.y)*s);
      const cd = (e.type==='bandit'? 380:450);
      if(overlap(e,player) && (now()-e.lastHit)>cd){
        e.lastHit=now();
        damagePlayer(e.dmg,'hit');
      }
    });

    // bosses in map
    ensureBossForMap(player.map);

    if(player.map.bossDef){
      const id = player.map.bossDef.id;
      const b = bosses[id];
      if(b && b.alive){
        bossAI(b, dt);
      }
      // boss death -> drops
      if(b && !b.alive && !b._dropped){
        b._dropped=true;
        if(id==='boss1'){ grant('key2'); toast('+ key2'); }
        if(id==='boss2'){ grant('key3'); toast('+ key3'); }
        if(id==='boss3'){
          // final boss phase logic
          if(bosses.finalPhase===1){
            // phase 2: revive/spawn all 3 together
            bosses.finalPhase=2;
            toast('FINAL: PHASE 2!');
            // ensure boss1 & boss2 exist (spawn them into boss map positions)
            bosses.boss1 = bosses.boss1 && bosses.boss1.alive ? bosses.boss1 : { ...spawnBoss('boss1', MAP_FOREST), x: 7*TILE, y: 4*TILE };
            bosses.boss2 = bosses.boss2 && bosses.boss2.alive ? bosses.boss2 : { ...spawnBoss('boss2', MAP_FROST), x: 7*TILE, y: 8*TILE };
            // respawn final with lower hp
            bosses.boss3 = { ...spawnBoss('boss3', MAP_BOSS), hp: Math.floor(D().bossHp3*0.75), hpMax: Math.floor(D().bossHp3*0.75) };
          } else {
            // phase2 won
            player.hasWon=true;
            ending();
          }
        }
      }
    }

    // phase2 boss lair: run AI for all 3
    if(player.map===MAP_BOSS && bosses.finalPhase===2){
      [bosses.boss1,bosses.boss2,bosses.boss3].forEach(b=> b && b.alive && bossAI(b, dt));
      // check win: all dead
      if((!bossAlive(bosses.boss1)) && (!bossAlive(bosses.boss2)) && (!bossAlive(bosses.boss3))){
        player.hasWon=true;
        ending();
      }
    }

    // projectiles
    arrows.forEach(a=>{
      a.x+=a.vx*dt; a.y+=a.vy*dt; a.life-=dt*1000;
      const ta=tileAt(player.map,a.x,a.y);
      if(isBlocked(ta.id)) a.life=0;
    });
    fireballs.forEach(f=>{
      f.x+=f.vx*dt; f.y+=f.vy*dt; f.life-=dt*1000;
      const tf=tileAt(player.map,f.x,f.y);
      if(isBlocked(tf.id)) f.life=0;
      if(overlap(f,player)){
        damagePlayer(D().fire,'fire');
        f.life=0;
      }
    });

    handleArrowHits();

    for(let i=arrows.length-1;i>=0;i--) if(arrows[i].life<=0) arrows.splice(i,1);
    for(let i=fireballs.length-1;i>=0;i--) if(fireballs[i].life<=0) fireballs.splice(i,1);

    handleTiles();
    render();
    requestAnimationFrame(update);
  }

  // ================= TILE INTERACTIONS =================
  function handleTiles(){
    const center={x:player.x+player.w/2, y:player.y+player.h/2};
    const t=tileAt(player.map, center.x, center.y);

    // chests (E)
    (player.map.chests||[]).forEach(ch=>{
      if(ch.opened) return;
      const box={x:ch.x*TILE+2,y:ch.y*TILE+2,w:12,h:12};
      if(overlap({x:center.x-1,y:center.y-1,w:2,h:2}, box)){
        if(keys.get('e')){
          ch.opened=true;
          if(ch.item==='potion'){
            player.hp = Math.min(player.hpMax, player.hp+5);
            toast('Healed!');
          } else {
            grant(ch.item);
          }
        } else say(L().chest, 900);
      }
    });

    // npcs (E)
    (player.map.npcs||[]).forEach(n=>{
      const box={x:n.x*TILE+1,y:n.y*TILE+1,w:14,h:14};
      if(overlap({x:center.x-1,y:center.y-1,w:2,h:2}, box)){
        if(keys.get('e')) say(n.text, 1600);
        else say(L().talk, 900);
      }
    });

    // portals require E (this fixes your “key but no world” issue)
    (player.map.doors||[]).forEach(d=>{
      if(t.x===d.x && t.y===d.y){
        // show hint always
        if(!keys.get('e')){
          say(`${L().pressE} · ${L().portal}${d.label}`, 700);
          return;
        }

        // secret portal: cutscene
        if(d.secretPortal){
          secretCutscene();
          return;
        }

        // requirements
        if(d.requireKey && !has(d.requireKey)){
          say(L().locked + d.requireKey, 1100);
          return;
        }
        if(d.requireItems && d.requireItems.some(it=>!has(it))){
          say(L().need + d.requireItems.join(' + '), 1200);
          return;
        }

        setCheckpoint();
        changeMap(d.to, d.tx, d.ty);
        toast(L().portal + d.label);
      }
    });
  }

  function fade(after){
    let a=1;
    const step=()=>{
      ctx.fillStyle=`rgba(0,0,0,${a})`;
      ctx.fillRect(0,0,W,H);
      a-=0.08;
      if(a>0) requestAnimationFrame(step);
      else after();
    };
    step();
  }

  function changeMap(map, tx, ty){
    if(transitioning) return;
    transitioning=true;
    fade(()=>{
      player.map=map;
      enemies=spawnForMap(map);
      player.x=tx*TILE+2;
      player.y=ty*TILE+2;
      arrows.length=0; fireballs.length=0;
      transitioning=false;

      // entering final boss map resets phase if not started
      if(map===MAP_BOSS && bosses.finalPhase===1 && !bosses.boss3){
        bosses.boss3 = spawnBoss('boss3', MAP_BOSS);
      }
    });
  }

  // ================= END / DEATH / RESPAWN =================
  function ending(){
    paused=true;
    UI.pause.classList.remove('active');
    show(UI.cutscene,true);
    UI.cutscene.innerHTML = `<b>${L().win}</b><br/>Phase complete. Press <b>T</b> then Main Menu.`;
  }

  function markSlotDead(){
    all = loadAll();
    const idx = player.slot||0;
    const existing = all.slots[idx] || {};
    all.slots[idx] = {
      ...existing,
      dead:true,
      name: existing.name || player.name || '',
      ts: Date.now(),
      map: player.map?.name || 'Overworld',
      hp: 0, hpMax: player.hpMax,
      inv: player.inv || [],
      hasWon:false,
      x: player.x, y: player.y
    };
    saveAll(all);
  }

  function onDeath(){
    const hard = getDiff()==='hard';
    paused=true;
    UI.pause.classList.add('active');
    if(hard){
      say(L().perm**adeath, 1800); // fix fallback if typo
      say(L().perm**adeath, 1800);
      // actually use correct key
      say(L().permadeath, 1800);
      markSlotDead();
      setTimeout(()=>returnToMenu(), 900);
      return;
    }
    say("You died…", 1100);
    setTimeout(()=>respawn(), 650);
  }

  function respawn(){
    const cp = player.checkpoint || {mapName:'Overworld', x:2*TILE, y:2*TILE};
    const mapByName=(n)=>{
      if(n==='Glimmer Caves') return MAP_CAVE;
      if(n==='Forest Ruins') return MAP_FOREST;
      if(n==='Frost Shrine') return MAP_FROST;
      if(n==='Shadow Nexus') return MAP_SHADOW;
      if(n==='Boss Lair') return MAP_BOSS;
      if(n==='???') return MAP_SECRET;
      return MAP_OVERWORLD;
    };
    player.map = mapByName(cp.mapName);
    player.x = cp.x; player.y = cp.y;
    player.hp = player.hpMax;
    player.iFrames = 600;
    enemies = spawnForMap(player.map);
    arrows.length=0; fireballs.length=0;
    paused=false;
    UI.pause.classList.remove('active');
    toast(L().respawn);
  }

  // ================= SECRET CUTSCENE =================
  function secretCutscene(){
    paused=true;
    UI.pause.classList.remove('active');
    show(UI.cutscene,true);
    UI.cutscene.innerHTML =
      `<b>Secret Cutscene</b><br/><br/>
      <span class="name">Developer</span>: Ferris<br/>
      <span class="name">Easter Eggs / Codes</span>:<br/>
      - BLOCK-BLOCK (gives Shield)<br/>
      - ROW-ROW-BOW (gives Bow)<br/>
      - WIN-WIN-WIN (instant win)<br/>
      - End-End (secret dimension)<br/><br/>
      <span class="name">Contact</span>: max.musterman@fakemail.com<br/><br/>
      <b>Message:</b> Thank you for playing. You are a true hero — not only for finishing the game, but for finishing it in secret.<br/><br/>
      Press <b>T</b> then Main Menu.`;
  }

  // ================= MINI CHAT (R) =================
  function toggleChat(){
    chatOpen = !chatOpen;
    UI.chat.classList.toggle('active', chatOpen);
    if(chatOpen){
      chatInput.value='';
      chatInput.focus();
    } else {
      chatInput.blur();
    }
  }
  function closeChat(){
    chatOpen=false;
    UI.chat.classList.remove('active');
    chatInput.blur();
  }

  function speak(text){
    player.speech.text = text;
    player.speech.timer = 3000;
  }

  chatInput.addEventListener('keydown', (e)=>{
    if(e.key==='Enter'){
      const raw = (chatInput.value||'').trim();
      if(!raw) return;
      handleChatCommand(raw);
      chatInput.value='';
      closeChat();
    }
  });

  function handleChatCommand(raw){
    const cmd = raw.toUpperCase();

    // normal speech
    speak(raw);

    // secret codes
    if(cmd==='BLOCK-BLOCK'){
      grant('shield');
      toast('CHEAT: shield');
      return;
    }
    if(cmd==='ROW-ROW-BOW'){
      grant('bow');
      toast('CHEAT: bow');
      return;
    }
    if(cmd==='WIN-WIN-WIN'){
      player.hasWon=true;
      ending();
      return;
    }
    if(cmd==='END-END'){
      toast(L().secret);
      // send to secret map
      changeMap(MAP_SECRET, 10, 9);
      // wipe enemies/bosses to keep it empty
      enemies=[];
      return;
    }
  }

  // ================= MENUS / SAVE =================
  const setMenu=(which)=>{
    UI.menu.classList.toggle('active', which==='main');
    UI.load.classList.toggle('active', which==='load');
    UI.settings.classList.toggle('active', which==='settings');
  };

  function buildSlots(){
    const el=document.getElementById('slots');
    el.innerHTML='';
    const fmt=ts=> new Date(ts).toLocaleString();
    all=loadAll();

    all.slots.forEach((slot,idx)=>{
      const card=document.createElement('div');
      card.className='slot';
      const name=slot?.name||'';
      const dead=!!slot?.dead;

      card.innerHTML=`
        <h3>Slot ${idx+1} ${name? '— '+name:''} ${dead? '— ☠ DEAD':''}</h3>
        <div class="row">
          <input type="text" placeholder="Name this slot" value="${name}" class="slotname"/>
          <button class="btn ok" data-idx="${idx}" data-act="saveName">Save name</button>
        </div>
        <p class="note">${slot ? `HP ${slot.hp}/${slot.hpMax} · ${slot.map||'Overworld'} · ${slot.hasWon?'✨ Won':(dead?'☠ Dead':'In progress')} · Saved ${fmt(slot.ts)}` : 'Empty slot'}</p>
        <div class="row">
          <button class="btn primary" data-idx="${idx}" data-act="continue" ${slot && !dead ? '' : 'disabled'}>Continue</button>
          <button class="btn" data-idx="${idx}" data-act="newHere">New Here</button>
          <button class="btn danger" data-idx="${idx}" data-act="erase">Delete</button>
        </div>
      `;
      el.appendChild(card);
    });

    el.querySelectorAll('button').forEach(b=> b.addEventListener('click', evSlotBtn));
  }

  function evSlotBtn(e){
    const idx=+e.target.dataset.idx;
    const act=e.target.dataset.act;
    const card=e.target.closest('.slot');
    const nameInput=card.querySelector('.slotname');

    if(act==='saveName'){
      const name=(nameInput.value||'').trim();
      if(name.toLowerCase()==='pia'){ show(UI.egg,true); setTimeout(()=>show(UI.egg,false), 3000); }
      all=loadAll();
      all.slots[idx]=all.slots[idx]||{};
      all.slots[idx].name=name;
      saveAll(all);
      toast('Name saved');
      return;
    }

    if(act==='continue'){ loadFromSlot(idx); startGame(); return; }
    if(act==='newHere'){ newGame(idx); startGame(); return; }
    if(act==='erase'){ all=loadAll(); all.slots[idx]=null; saveAll(all); buildSlots(); toast('Slot cleared'); return; }
  }

  function newGame(slotIndex){
    player=makePlayer();
    player.slot=slotIndex;
    all=loadAll();
    player.name = all.slots[slotIndex]?.name||'';

    // reset bosses
    bosses = { boss1:null, boss2:null, boss3:null, finalPhase:1 };

    inGame=true;
    HUD.root.style.display='flex';
    enemies=spawnForMap(player.map);
  }

  function loadFromSlot(idx){
    all=loadAll();
    const s=all.slots[idx];
    if(!s){ newGame(idx); return; }
    if(s.dead){ toast(L().deadSlot); newGame(idx); return; }

    player=makePlayer();
    player.slot=idx;

    Object.assign(player,{
      x:s.x??player.x, y:s.y??player.y,
      hp:s.hp??player.hp, hpMax:s.hpMax??player.hpMax,
      inv:s.inv||[],
      hasWon:!!s.hasWon,
      name:s.name||'',
      checkpoint: s.checkpoint || player.checkpoint
    });

    const mapByName=(n)=>{
      if(n==='Glimmer Caves') return MAP_CAVE;
      if(n==='Forest Ruins') return MAP_FOREST;
      if(n==='Frost Shrine') return MAP_FROST;
      if(n==='Shadow Nexus') return MAP_SHADOW;
      if(n==='Boss Lair') return MAP_BOSS;
      if(n==='???') return MAP_SECRET;
      return MAP_OVERWORLD;
    };
    player.map=mapByName(s.map);

    // restore boss state if present
    bosses = s.bosses || { boss1:null, boss2:null, boss3:null, finalPhase:1 };

    enemies=spawnForMap(player.map);
  }

  function saveToSlot(){
    if(!inGame) return;
    if(getDiff()==='hard'){ toast(L().hardNoSave); return; }

    const idx=player.slot||0;
    all=loadAll();
    const existing=all.slots[idx]||{};

    all.slots[idx]={
      x:player.x,y:player.y,
      hp:player.hp,hpMax:player.hpMax,
      inv:player.inv,
      map:player.map.name,
      hasWon:player.hasWon,
      name: existing.name||player.name||'',
      ts: Date.now(),
      dead:false,
      checkpoint: player.checkpoint,
      bosses: bosses
    };
    saveAll(all);
    toast(L().saved);
  }

  function startGame(){
    setMenu(null);
    show(HUD.root,true);
    inGame=true;
    paused=false;
    UI.pause.classList.remove('active');
    BTN.save.disabled = (getDiff()==='hard');
    requestAnimationFrame(update);
    render();
  }

  function returnToMenu(){
    inGame=false;
    paused=false;
    UI.pause.classList.remove('active');
    HUD.root.style.display='none';
    setMenu('main');
  }

  // ================= UI WIRING =================
  BTN.new.addEventListener('click', ()=>{ setMenu('load'); buildSlots(); toast(L().pickSlot); });
  BTN.load.addEventListener('click', ()=>{ setMenu('load'); buildSlots(); });
  BTN.settings.addEventListener('click', ()=> setMenu('settings'));
  BTN.exit.addEventListener('click', ()=>{
    window.close();
    setTimeout(()=>{ document.body.innerHTML='<div style="display:flex;align-items:center;justify-content:center;height:100vh;color:#ccd">Goodbye!</div>'; }, 100);
  });
  BTN.backFromLoad.addEventListener('click', ()=> setMenu('main'));
  BTN.backFromSettings.addEventListener('click', ()=> setMenu('main'));

  BTN.login.addEventListener('click', ()=>{
    all=loadAll();
    all.settings.nick=inputNick.value.trim();
    saveAll(all);
    toast(`Welcome${all.settings.nick? ', '+all.settings.nick:''}!`);
  });

  ddDifficulty.addEventListener('change', ()=>{
    all=loadAll();
    all.settings.difficulty=ddDifficulty.value;
    saveAll(all);
    toast('Difficulty: '+ddDifficulty.value.toUpperCase());
    BTN.save.disabled = (getDiff()==='hard');
  });

  ddLang.addEventListener('change', ()=>{
    all=loadAll();
    all.settings.lang=ddLang.value;
    saveAll(all);
    applyLang();
    toast('Language set.');
  });

  BTN.resume.addEventListener('click', ()=> togglePause());
  BTN.save.addEventListener('click', ()=> saveToSlot());
  BTN.mainMenu.addEventListener('click', ()=>{ saveToSlot(); returnToMenu(); });

  window.addEventListener('blur', ()=>{ if(inGame){ paused=true; UI.pause.classList.add('active'); BTN.save.disabled=(getDiff()==='hard'); }});

  // boot
  setMenu('main');
  show(HUD.root,false);
  toast('Ready! New Game → choose a slot.');
  requestAnimationFrame(update);
})();
</script>
</body>
</
